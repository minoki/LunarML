(*
 * Copyright (c) 2022 ARATA Mizuki
 * This file is part of LunarML.
 *)
fun nilPat span = UnfixedSyntax.NonInfixVIdPat (span, Syntax.MkLongVId (nil, Syntax.MkVId ("nil")))
fun trueExp span = UnfixedSyntax.NonInfixVIdExp (span, Syntax.MkLongVId (nil, Syntax.MkVId ("true")))
fun falseExp span = UnfixedSyntax.NonInfixVIdExp (span, Syntax.MkLongVId (nil, Syntax.MkVId ("false")))
fun nilExp span = UnfixedSyntax.NonInfixVIdExp (span, Syntax.MkLongVId (nil, Syntax.MkVId ("nil")))
fun consOp span = UnfixedSyntax.NonInfixVIdExp (span, Syntax.MkLongVId (nil, Syntax.MkVId ("::")))
fun MkAndAlsoExp (span,e1,e2) = UnfixedSyntax.IfThenElseExp (span, e1, e2, falseExp span)
fun MkOrElseExp (span,e1,e2) = UnfixedSyntax.IfThenElseExp (span, e1, trueExp span, e2)
fun MkPairExp (span,e1,e2) = UnfixedSyntax.RecordExp(span, [UnfixedSyntax.Field (Syntax.NumericLabel 1, e1), UnfixedSyntax.Field (Syntax.NumericLabel 2, e2)])
fun MkConsExp (span,e1,e2) = UnfixedSyntax.AppExp (span, consOp span, MkPairExp (span, e1,e2))
fun MkListExp (span, xs) = UnfixedSyntax.ListExp(span, Vector.fromList xs)
fun MkVectorExp (span, xs) = UnfixedSyntax.VectorExp(span, Vector.fromList xs)
fun MkPairPat (span, p1, p2) = UnfixedSyntax.TuplePat(span, [p1, p2])
fun MkConsPat (span, p1, p2) = UnfixedSyntax.ConPat(span, Syntax.MkLongVId(nil, Syntax.MkVId("::")), MkPairPat(span, p1, p2))
fun MkListPat (span, nil) = nilPat span
  | MkListPat (span, x :: xs) = MkConsPat (span, x, MkListPat (span, xs))
fun MkVectorPat (span, xs, ellipsis) = UnfixedSyntax.VectorPat(span, Vector.fromList xs, ellipsis)
fun MkSequentialExp (span, e1, []) = e1
  | MkSequentialExp (span, e1, e2 :: xs) = UnfixedSyntax.CaseExp(span,e1,[(UnfixedSyntax.WildcardPat span, MkSequentialExp(span,e2,xs))])
fun MkTupleTy(_,[x]) = x
  | MkTupleTy(span, xs) = let fun doFields i nil = nil
                                | doFields i (t :: ts) = (Syntax.NumericLabel i, t) :: doFields (i + 1) ts
                          in Syntax.RecordType (span, doFields 1 xs, NONE)
                          end
fun prependStrId(strid, Syntax.MkQualified(strids, x)) = Syntax.MkQualified(strid :: strids, x)
fun span(p1,p2) = { start = p1, end_ = p2 }
%%

%eop EOF
%pos SourcePos.pos
%pure
%arg (filename) : string

%term AlnumIdent of string (* alphanumeric identifier not starting with a prime *)
    | QualifiedAlnumIdent of string list * string
    | PrimeIdent of string (* alphanumeric identifier starting with a prime *)
    | SymbolicIdent of string
    | QualifiedSymbolicIdent of string list * string
    | PosInt of IntInf.int (* positive integer literal, not starting with 0, and not containing any underscore *)
    | ZNIntConst of IntInf.int (* starting with 0, or negative integer literal, or contains an underscore *)
    | WordConst of IntInf.int (* non-negative *)
    | RealConst of Numeric.float_notation
    | StringConst of StringElement.char vector
    | AsciiStringConst of string * StringElement.char vector
    | CharacterConst of int
    (* * *)
    | ASTERISK
    (* . *)
    | DOT (* not used by the grammar *)
    (* ( ) [ ] { } , : *)
    | LPAREN | RPAREN | LBRACK | RBRACK | LBRACE | RBRACE | COMMA | COLON
    (* ; ... _ | = => -> # *)
    | SEMICOLON | ELLIPSIS | UNDERSCORE | BAR | EQUALS | DARROW | ARROW | HASH
    (* :> *)
    | COLONGT
    (* #[ (extension) *)
    | HASHLBRACK
    (* reserved words *)
    | ABSTYPE | AND | ANDALSO | AS | CASE | DATATYPE | DO | ELSE | END | EQTYPE
    | EXCEPTION | FN | FUN | FUNCTOR | HANDLE | IF | IN | INCLUDE | INFIX
    | INFIXR | LET | LOCAL | NONFIX | OF | OP | OPEN | ORELSE | RAISE | REC
    | SHARING | SIG | SIGNATURE | STRUCT | STRUCTURE | THEN | TYPE | VAL | WITH
    | WITHTYPE | WHERE | WHILE
    (* reserved words (extension) *)
    | PRIMTYPE | PRIMVAL | PRIMCALL | OVERLOAD
    (* other *)
    | EOF
%nonterm START of ((UnfixedSyntax.Dec Syntax.TopDec) list) list
       | IntConst of IntInf.int
       | SCon of Syntax.SCon
       | TyVar of Syntax.TyVar
       | VId of Syntax.VId
       | BoundVId of Syntax.VId
       | StrId of Syntax.StrId
       | SigId of Syntax.SigId
       | FunId of Syntax.FunId
       | Lab of Syntax.Label
       | TyCon of Syntax.TyCon
       | LongVId of Syntax.LongVId
       | LongBoundVId of Syntax.LongVId
       | LongTyCon of Syntax.LongTyCon
       | LongStrId of Syntax.LongStrId
       | Opt_OP of bool
       | AtPat of UnfixedSyntax.Pat
       | AtPats of UnfixedSyntax.Pat list
       | TypedPatPun of Syntax.Label * UnfixedSyntax.Pat
       | PatPun of Syntax.Label * UnfixedSyntax.Pat
       | PatRow of (UnfixedSyntax.Pat UnfixedSyntax.RecordItem) list
       | PatRowRest of (UnfixedSyntax.Pat UnfixedSyntax.RecordItem) list
       | AppOrInfPat of UnfixedSyntax.Pat list
       | TypedPat of UnfixedSyntax.Pat
       | Pat of UnfixedSyntax.Pat
       | PatSeqRest of UnfixedSyntax.Pat list
       | PatSeqRestEllipsis of UnfixedSyntax.Pat list * bool
       | AtTy of Syntax.Ty
       | LongTyConOrPrimTyCon of Syntax.LongTyCon
       | ConTy of Syntax.Ty
       | TupTy of Syntax.Ty list
       | Ty_NoARROW of Syntax.Ty
       | Ty of Syntax.Ty
       | TySeqRest of Syntax.Ty list
       | TyVarSeq of Syntax.TyVar list
       | TyVarSeqRest of Syntax.TyVar list
       | TyRow of (Syntax.Label * Syntax.Ty) list * Syntax.Ty option
       | COMMA_TyRow_NoELLIPSIS of (Syntax.Label * Syntax.Ty) list
       | AtExp of UnfixedSyntax.Exp
       | AppOrInfExp of UnfixedSyntax.Exp list
       | ExpRow of (UnfixedSyntax.Exp UnfixedSyntax.RecordItem) list
       | ExpRowRest of (UnfixedSyntax.Exp UnfixedSyntax.RecordItem) list
       | ExpCSeqRest of UnfixedSyntax.Exp list
       | ExpSSeqRest of UnfixedSyntax.Exp list
       | TypedExp of UnfixedSyntax.Exp
       | AndalsoExp of UnfixedSyntax.Exp
       | AndalsoExp_NoHead of UnfixedSyntax.Exp
       | AndalsoExp_NoMatch of UnfixedSyntax.Exp
       | OrelseExp of UnfixedSyntax.Exp
       | OrelseExp_NoHead of UnfixedSyntax.Exp
       | OrelseExp_NoMatch of UnfixedSyntax.Exp
       | Exp of UnfixedSyntax.Exp
       | Exp_NoMatch of UnfixedSyntax.Exp
       | HeadExp of UnfixedSyntax.Exp
       | HeadExp_NoMatch of UnfixedSyntax.Exp
       | MatchClauses of (UnfixedSyntax.Pat * UnfixedSyntax.Exp) list
       | MRule of UnfixedSyntax.Pat * UnfixedSyntax.Exp
       | Dec_NoLocal of UnfixedSyntax.Dec
       | OverloadSpec of string * UnfixedSyntax.Exp
       | OverloadSpecs of (string * UnfixedSyntax.Exp) list
       | Dec of UnfixedSyntax.Dec
       | Decs of UnfixedSyntax.Dec list
       | LongStrIds of Syntax.LongStrId list
       | VIds of Syntax.VId list
       | ValBind of UnfixedSyntax.ValBind list
       | FValBind of UnfixedSyntax.FValBind list
       | FMatch of UnfixedSyntax.FMRule list
       | FMRule of UnfixedSyntax.FMRule
       | FMRule_NoMatch of UnfixedSyntax.FMRule
       | FPat of UnfixedSyntax.FPat
       | TypBind of Syntax.TypBind list
       | DatBind of Syntax.DatBind list
       | DatBindRest of Syntax.DatBind list
       | Withtype of Syntax.TypBind list
       | ConBind of Syntax.ConBind list
       | ConBindRest of Syntax.ConBind list
       | ExBind of Syntax.ExBind list
       | ExBindRest of Syntax.ExBind list
       | AtStrExp of UnfixedSyntax.Dec Syntax.StrExp
       | StrExp of UnfixedSyntax.Dec Syntax.StrExp
       | StrExp_AND of UnfixedSyntax.Dec Syntax.StrExp
       | ProperStrDec of UnfixedSyntax.Dec Syntax.StrDec
       | StrDecs of (UnfixedSyntax.Dec Syntax.StrDec) list
       | StrBind of (Syntax.StrId * UnfixedSyntax.Dec Syntax.StrExp) list
       | Spec of Syntax.Spec list
       | ValDesc of (Syntax.VId * Syntax.Ty) list
       | TypDesc of (Syntax.TyVar list * Syntax.TyCon) list
       | TypDescRest of (Syntax.TyVar list * Syntax.TyCon) list
       | TypDescEQRest of (Syntax.TyVar list * Syntax.TyCon * Syntax.Ty) list
       | DatDescRest of (Syntax.TyVar list * Syntax.TyCon * Syntax.ConBind list) list
       | ConDesc of Syntax.ConBind list
       | ConDescRest of Syntax.ConBind list
       | ExDesc of (Syntax.VId * Syntax.Ty option) list
       | ExDescRest of (Syntax.VId * Syntax.Ty option) list
       | StrDesc of (Syntax.StrId * Syntax.SigExp) list
       | SigIds of Syntax.SigId list
       | Specs_NoSharing of Syntax.Spec list
       | Specs of Syntax.Spec list
       | EQUAL_LongTyCons of Syntax.LongTyCon list
       | EQUAL_LongStrIds of Syntax.LongStrId list
       | SigExp_NoSigId of Syntax.SigExp
       | SigExp of Syntax.SigExp
       | SigExp_AND of Syntax.SigExp
       | TypeRealisationRest of (SourcePos.span * Syntax.TyVar list * Syntax.LongTyCon * Syntax.Ty) list
       | TypeRealisationRest_AND of (SourcePos.span * Syntax.TyVar list * Syntax.LongTyCon * Syntax.Ty) list
       | SigBinds of (Syntax.SigId * Syntax.SigExp) list
       | SigDec of (Syntax.SigId * Syntax.SigExp) list
       | SigConstraint of UnfixedSyntax.Dec Syntax.StrExp -> UnfixedSyntax.Dec Syntax.StrExp
       | FunDec of (SourcePos.span * Syntax.FunId * UnfixedSyntax.Dec Syntax.FunExp) list
       | FunBind of (SourcePos.span * Syntax.FunId * UnfixedSyntax.Dec Syntax.FunExp) list
       | TopDecs of (UnfixedSyntax.Dec Syntax.TopDec) list
       | Program of ((UnfixedSyntax.Dec Syntax.TopDec) list) list

%name LunarML

%noshift EOF
%nodefault

%right ARROW (* function type expression *)

%verbose

%%

START : Program (Program)

IntConst : PosInt (PosInt)
         | ZNIntConst (ZNIntConst)

SCon : IntConst (Syntax.IntegerConstant IntConst)
     | WordConst (Syntax.WordConstant WordConst)
     | RealConst (Syntax.RealConstant RealConst)
     | StringConst (Syntax.StringConstant StringConst)
     | AsciiStringConst (Syntax.StringConstant (#2 AsciiStringConst))
     | CharacterConst (Syntax.CharacterConstant CharacterConst)

(* type variable *)
TyVar : PrimeIdent (Syntax.MkTyVar PrimeIdent)

(* value identifiers *)
VId : BoundVId (BoundVId)
    | EQUALS (Syntax.MkVId "=") (* ? *)

(* value identifiers, excluding '=' *)
BoundVId : AlnumIdent (Syntax.MkVId AlnumIdent)
         | SymbolicIdent (Syntax.MkVId SymbolicIdent)
         | ASTERISK (Syntax.MkVId "*")

(* structure identifier *)
StrId : AlnumIdent (Syntax.MkStrId AlnumIdent)

(* signature identifier *)
SigId : AlnumIdent (Syntax.MkSigId AlnumIdent)

(* functor identifier *)
FunId : AlnumIdent (Syntax.MkFunId AlnumIdent)

(* record labels *)
Lab : AlnumIdent (Syntax.IdentifierLabel AlnumIdent)
    | SymbolicIdent (Syntax.IdentifierLabel SymbolicIdent)
    | ASTERISK (Syntax.IdentifierLabel "*")
    | PosInt (Syntax.NumericLabel (Int.fromLarge PosInt)) (* numeric labels *)

(* type constructors; "*" is not included *)
TyCon : AlnumIdent (Syntax.MkTyCon AlnumIdent)
      | SymbolicIdent (Syntax.MkTyCon SymbolicIdent)

(* long value identifiers, including '=' *)
LongVId : VId (Syntax.MkLongVId (nil, VId))
        | QualifiedAlnumIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedAlnumIdent), Syntax.MkVId (#2 QualifiedAlnumIdent)))
        | QualifiedSymbolicIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedSymbolicIdent), Syntax.MkVId (#2 QualifiedSymbolicIdent)))

(* long value identifiers, excluding unqualified '=' *)
LongBoundVId : BoundVId (Syntax.MkLongVId (nil, BoundVId))
             | QualifiedAlnumIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedAlnumIdent), Syntax.MkVId (#2 QualifiedAlnumIdent)))
             | QualifiedSymbolicIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedSymbolicIdent), Syntax.MkVId (#2 QualifiedSymbolicIdent)))

(* long type constructors *)
LongTyCon : TyCon (Syntax.MkLongTyCon (nil, TyCon))
          | QualifiedAlnumIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedAlnumIdent), Syntax.MkTyCon (#2 QualifiedAlnumIdent)))
          | QualifiedSymbolicIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedSymbolicIdent), Syntax.MkTyCon (#2 QualifiedSymbolicIdent)))

(* long structure identifiers *)
LongStrId : StrId (Syntax.MkLongStrId (nil, StrId))
          | QualifiedAlnumIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedAlnumIdent), Syntax.MkStrId (#2 QualifiedAlnumIdent)))

Opt_OP : (* empty *) (false)
       | OP (true)

(* atomic patterns *)
AtPat : UNDERSCORE (UnfixedSyntax.WildcardPat(span(UNDERSCOREleft,UNDERSCOREright))) (* wildcard *)
      | SCon (UnfixedSyntax.SConPat(span(SConleft,SConright),SCon)) (* special constant *)
      | OP LongVId (UnfixedSyntax.NonInfixVIdPat(span(OPleft,LongVIdright),LongVId)) (* value identifier, including 'op =' *)
      | LongBoundVId (case LongBoundVId of
                          Syntax.MkQualified([], vid) => UnfixedSyntax.InfixOrVIdPat(span(LongBoundVIdleft,LongBoundVIdright),vid)
                        | longvid => UnfixedSyntax.NonInfixVIdPat(span(LongBoundVIdleft,LongBoundVIdright),longvid)
                     ) (* value identifier *)
      | LBRACE RBRACE (UnfixedSyntax.RecordPat (span (LBRACEleft, RBRACEright), [])) (* empty record *)
      | LBRACE PatRow RBRACE (UnfixedSyntax.RecordPat (span (LBRACEleft, RBRACEright), PatRow)) (* record *)
      | LPAREN RPAREN (UnfixedSyntax.RecordPat (span(LPARENleft,RPARENright), [])) (* [derived] empty tuple *)
      | LPAREN Pat RPAREN (case Pat of
                               UnfixedSyntax.InfixOrVIdPat _ => UnfixedSyntax.JuxtapositionPat(span(LPARENleft,RPARENright), [Pat])
                             | pat => pat
                          ) (* parenthesized pattern *)
      | LPAREN Pat COMMA Pat PatSeqRest RPAREN (UnfixedSyntax.TuplePat(span(LPARENleft,RPARENright), Pat1 :: Pat2 :: PatSeqRest)) (* [derived] tuple pattern *)
      | LBRACK RBRACK (nilPat (span(LBRACKleft,RBRACKright))) (* [derived] empty list *)
      | LBRACK Pat PatSeqRest RBRACK (MkListPat(span(LBRACKleft,RBRACKright), Pat :: PatSeqRest)) (* [derived] list pattern *)
      | HASHLBRACK RBRACK (MkVectorPat(span(HASHLBRACKleft,RBRACKright), [], false)) (* [extension] vector list *)
      | HASHLBRACK ELLIPSIS RBRACK (MkVectorPat(span(HASHLBRACKleft,RBRACKright), [], true)) (* [extension] vector list *)
      | HASHLBRACK Pat PatSeqRestEllipsis RBRACK (case PatSeqRestEllipsis of (PatSeqRest, ellipsis) => MkVectorPat(span(HASHLBRACKleft,RBRACKright), Pat :: PatSeqRest, ellipsis)) (* [extension] vector pattern *)

(* one or more atomic patterns *)
AtPats : AtPat ([AtPat])
       | AtPat AtPats (AtPat :: AtPats)

TypedPat : AtPats (UnfixedSyntax.JuxtapositionPat(span(AtPatsleft, AtPatsright), AtPats))
         | TypedPat COLON Ty (UnfixedSyntax.TypedPat (span(TypedPatleft, Tyright), TypedPat, Ty)) (* typed *)

(* patterns *)
Pat : TypedPat (TypedPat)
(*
    | OP VId COLON Ty AS Pat (UnfixedSyntax.LayeredPat (OP_VId, SOME Ty, Pat)) (* layered *)
    | OP VId AS Pat (UnfixedSyntax.LayeredPat (OP_VId, NONE, Pat)) (* layered *)
    | BoundVId COLON Ty AS Pat (UnfixedSyntax.LayeredPat (OP_VId, SOME Ty, Pat)) (* layered *)
    | BoundVId AS Pat (UnfixedSyntax.LayeredPat (OP_VId, NONE, Pat)) (* layered *)
*)
    | TypedPat AS Pat (UnfixedSyntax.ConjunctivePat(span(TypedPatleft,Patright), TypedPat, Pat)) (* layered or [Successor ML] conjunctive (R) *)

TypedPatPun : BoundVId ((Syntax.IdentifierLabel(Syntax.getVIdName BoundVId), UnfixedSyntax.NonInfixVIdPat(span(BoundVIdleft,BoundVIdright),Syntax.MkQualified([],BoundVId))))
            | BoundVId COLON Ty ((Syntax.IdentifierLabel(Syntax.getVIdName BoundVId), UnfixedSyntax.TypedPat(span(BoundVIdleft,Tyright),UnfixedSyntax.NonInfixVIdPat(span(BoundVIdleft,BoundVIdright),Syntax.MkQualified([],BoundVId)),Ty)))

PatPun : TypedPatPun (TypedPatPun)
       | TypedPatPun AS Pat ((#1 TypedPatPun, UnfixedSyntax.ConjunctivePat(span(TypedPatPunleft,Patright), #2 TypedPatPun, Pat)))

(* pattern rows *)
PatRow : ELLIPSIS PatRowRest (UnfixedSyntax.Ellipsis (UnfixedSyntax.WildcardPat (span (ELLIPSISleft, ELLIPSISright))) :: PatRowRest) (* wildcard *)
       | ELLIPSIS EQUALS Pat PatRowRest (UnfixedSyntax.Ellipsis Pat :: PatRowRest) (* [Successor ML] ellipses *)
       | Lab EQUALS Pat PatRowRest (UnfixedSyntax.Field (Lab, Pat) :: PatRowRest) (* pattern row *)
       | PatPun PatRowRest (UnfixedSyntax.Field PatPun :: PatRowRest) (* [derived] punning *)

PatRowRest : COMMA PatRow (PatRow)
           | ([])

PatSeqRest : COMMA Pat PatSeqRest (Pat :: PatSeqRest)
           | (nil)

PatSeqRestEllipsis : COMMA Pat PatSeqRestEllipsis (case PatSeqRestEllipsis of (PatSeqRest, ellipsis) => (Pat :: PatSeqRest, ellipsis))
                   | COMMA ELLIPSIS ((nil, true))
                   | ((nil, false))

AtTy : TyVar (Syntax.TyVar(span(TyVarleft,TyVarright), TyVar))
     | LBRACE RBRACE (Syntax.RecordType(span(LBRACEleft, RBRACEright), nil, NONE)) (* record type expression *)
     | LBRACE TyRow RBRACE (Syntax.RecordType(span(LBRACEleft, RBRACEright), #1 TyRow, #2 TyRow)) (* record type expression *)
     | LPAREN Ty RPAREN (Ty)

LongTyConOrPrimTyCon : LongTyCon (LongTyCon)
                     | PRIMTYPE AsciiStringConst (Syntax.MkQualified([], Syntax.MkTyCon (#1 AsciiStringConst)))

ConTy : AtTy (AtTy)
      | ConTy LongTyConOrPrimTyCon (Syntax.TyCon (span(ConTyleft, LongTyConOrPrimTyConright), [ConTy], LongTyConOrPrimTyCon)) (* type construction *)
      | LongTyConOrPrimTyCon (Syntax.TyCon (span(LongTyConOrPrimTyConleft, LongTyConOrPrimTyConright), nil, LongTyConOrPrimTyCon)) (* type construction *)
      | LPAREN Ty COMMA Ty TySeqRest RPAREN LongTyConOrPrimTyCon (Syntax.TyCon (span(LPARENleft, LongTyConOrPrimTyConright), Ty1 :: Ty2 :: TySeqRest, LongTyConOrPrimTyCon)) (* type construction *)

TupTy : ConTy ([ConTy])
      | ConTy ASTERISK TupTy (ConTy :: TupTy)

(* type expressions *)
Ty : TupTy (MkTupleTy(span(TupTyleft, TupTyright), TupTy))
   | TupTy ARROW Ty (Syntax.FnType (span(TupTyleft, Tyright), MkTupleTy(span(TupTyleft, TupTyright), TupTy), Ty)) (* function type expression (R) *)
   (* tuple type *)

TySeqRest : COMMA Ty TySeqRest (Ty :: TySeqRest) (* *)
          | (nil) (* empty *)

TyVarSeq : TyVar ([TyVar]) (* singleton sequence *)
         | (nil) (* empty sequence *)
         | LPAREN TyVar TyVarSeqRest RPAREN (TyVar :: TyVarSeqRest) (* sequence *)

TyVarSeqRest : COMMA TyVar TyVarSeqRest (TyVar :: TyVarSeqRest) (* *)
             | (nil) (* empty *)

(* type-expression rows *)
TyRow : Lab COLON Ty COMMA TyRow (((Lab, Ty) :: #1 TyRow, #2 TyRow)) (* type-expression row *)
      | Lab COLON Ty (([(Lab, Ty)], NONE)) (* type-expression row *)
      | ELLIPSIS COLON Ty COMMA_TyRow_NoELLIPSIS ((COMMA_TyRow_NoELLIPSIS, SOME Ty)) (* [Successor ML] ellipses *)

COMMA_TyRow_NoELLIPSIS : COMMA Lab COLON Ty COMMA_TyRow_NoELLIPSIS ((Lab, Ty) :: COMMA_TyRow_NoELLIPSIS) (* type-expression row *)
                       | ([]) (* type-expression row *)

(* atomic expressions *)
AtExp : SCon (UnfixedSyntax.SConExp(span(SConleft,SConright),SCon)) (* special constant *)
      | OP LongVId (UnfixedSyntax.NonInfixVIdExp(span(OPleft,LongVIdright),LongVId)) (* value identifier *)
      | LongBoundVId (case LongBoundVId of
                          Syntax.MkQualified([], vid) => UnfixedSyntax.InfixOrVIdExp(span(LongBoundVIdleft,LongBoundVIdright),vid)
                        | longvid => UnfixedSyntax.NonInfixVIdExp(span(LongBoundVIdleft,LongBoundVIdright),longvid)
                     ) (* value identifier *)
      | EQUALS (UnfixedSyntax.InfixOrVIdExp(span(EQUALSleft,EQUALSright),Syntax.MkVId "="))
      | LBRACE RBRACE (UnfixedSyntax.RecordExp (span (LBRACEleft, RBRACEright), [])) (* empty record *)
      | LBRACE ExpRow RBRACE (UnfixedSyntax.RecordExp (span (LBRACEleft, RBRACEright), ExpRow)) (* record *)
      | LBRACE AtExp WHERE RBRACE (UnfixedSyntax.RecordUpdateExp (span (LBRACEleft, RBRACEright), AtExp, [])) (* [Successor ML] record update *)
      | LBRACE AtExp WHERE ExpRow RBRACE (UnfixedSyntax.RecordUpdateExp (span (LBRACEleft, RBRACEright), AtExp, ExpRow)) (* [Successor ML] record update *)
      | LET Decs IN Exp END (UnfixedSyntax.LetInExp (span(LETleft,ENDright), Decs, Exp)) (* local declaration *)
      | LPAREN Exp RPAREN (case Exp of
                               UnfixedSyntax.InfixOrVIdExp _ => UnfixedSyntax.JuxtapositionExp(span(LPARENleft,RPARENright),[Exp])
                             | exp => exp
                          ) (* parenthesized expression *)
      | LPAREN RPAREN (UnfixedSyntax.RecordExp (span (LPARENleft, RPARENright), [])) (* [derived] 0-tuple *)
      | LPAREN Exp COMMA Exp ExpCSeqRest RPAREN (UnfixedSyntax.TupleExp (span(LPARENleft,RPARENright), Exp1 :: Exp2 :: ExpCSeqRest)) (* [derived] tuple: {1=Exp1,...,n=Expn} (n >= 2) *)
      | LPAREN Exp SEMICOLON Exp ExpSSeqRest RPAREN (MkSequentialExp (span(LPARENleft,RPARENright), Exp1, Exp2 :: ExpSSeqRest)) (* [derived] sequential execution *)
      | LET Decs IN Exp SEMICOLON Exp ExpSSeqRest END (UnfixedSyntax.LetInExp (span(LETleft,ENDright), Decs, MkSequentialExp(span(Exp1left, ExpSSeqRestright), Exp1, Exp2 :: ExpSSeqRest))) (* [derived] local declaration *)
      | LBRACK RBRACK (MkListExp(span(LBRACKleft,RBRACKright),[])) (* [derived] list: Exp1 :: ... :: Expn :: nil *)
      | LBRACK Exp ExpCSeqRest RBRACK (MkListExp(span(LBRACKleft,RBRACKright), Exp :: ExpCSeqRest)) (* [derived] list: Exp1 :: ... :: Expn :: nil *)
      | HASHLBRACK RBRACK (MkVectorExp(span(HASHLBRACKleft,RBRACKright), [])) (* [extension] vector expression *)
      | HASHLBRACK Exp ExpCSeqRest RBRACK (MkVectorExp(span(HASHLBRACKleft,RBRACKright), Exp :: ExpCSeqRest)) (* [extension] vector expression *)
      | HASH Lab (UnfixedSyntax.ProjectionExp(span(HASHleft,Labright), Lab)) (* [derived] projection: fn {Lab=VId,...} => VId *)
      | PRIMVAL AsciiStringConst (UnfixedSyntax.PrimValExp(span(PRIMVALleft, AsciiStringConstright), #1 AsciiStringConst)) (* [extension] _primVal "name" *)
      | PRIMCALL AsciiStringConst LBRACK Ty TySeqRest RBRACK LPAREN RPAREN (UnfixedSyntax.PrimExp(span(PRIMCALLleft, RPARENright), #1 AsciiStringConst, vector (Ty :: TySeqRest), vector [])) (* [extension] _primCall "name" [tyargs] () *)
      | PRIMCALL AsciiStringConst LBRACK Ty TySeqRest RBRACK LPAREN Exp ExpCSeqRest RPAREN (UnfixedSyntax.PrimExp(span(PRIMCALLleft, RPARENright), #1 AsciiStringConst, vector (Ty :: TySeqRest), vector (Exp :: ExpCSeqRest))) (* [extension] _primCall "name" [tyargs] (args) *)
      | PRIMCALL AsciiStringConst LPAREN RPAREN (UnfixedSyntax.PrimExp(span(PRIMCALLleft, RPARENright), #1 AsciiStringConst, vector [], vector [])) (* [extension] _primCall "name" () *)
      | PRIMCALL AsciiStringConst LPAREN Exp ExpCSeqRest RPAREN (UnfixedSyntax.PrimExp(span(PRIMCALLleft, RPARENright), #1 AsciiStringConst, vector [], vector (Exp :: ExpCSeqRest))) (* [extension] _primCall "name" (args) *)

(* comma-separated list of expressions *)
ExpCSeqRest : COMMA Exp ExpCSeqRest (Exp :: ExpCSeqRest)
            | (nil)

(* semicolon-separated list of expressions *)
ExpSSeqRest : SEMICOLON Exp ExpSSeqRest (Exp :: ExpSSeqRest)
            | (nil)

(* expression rows *)
ExpRow : Lab EQUALS Exp ExpRowRest (UnfixedSyntax.Field (Lab, Exp) :: ExpRowRest)
       | ELLIPSIS EQUALS Exp ExpRowRest (UnfixedSyntax.Ellipsis Exp :: ExpRowRest) (* [Successor ML] ellipses *)

ExpRowRest : COMMA ExpRow (ExpRow)
           | ([])

(*
AppExp : AtExp
       | AppExp AtExp
InfExp : AppExp
       | InfExp VId InfExp
*)

AppOrInfExp : AtExp AppOrInfExp (AtExp :: AppOrInfExp) (* atomic *)
            | AtExp ([AtExp])

TypedExp : AppOrInfExp (UnfixedSyntax.JuxtapositionExp(span(AppOrInfExpleft,AppOrInfExpright), AppOrInfExp))
         | TypedExp COLON Ty (UnfixedSyntax.TypedExp (span(TypedExpleft,Tyright), TypedExp, Ty)) (* typed (L) *)

AndalsoExp : TypedExp (TypedExp)
           | TypedExp ANDALSO AndalsoExp (MkAndAlsoExp (span(TypedExpleft, AndalsoExpright), TypedExp, AndalsoExp)) (* [derived] conjunction *)
           | TypedExp ANDALSO HeadExp (MkAndAlsoExp (span(TypedExpleft, HeadExpright), TypedExp, HeadExp)) (* [derived] conjunction *)

AndalsoExp_NoHead : TypedExp (TypedExp)
                  | TypedExp ANDALSO AndalsoExp_NoHead (MkAndAlsoExp (span(TypedExpleft, AndalsoExp_NoHeadright), TypedExp, AndalsoExp_NoHead)) (* [derived] conjunction *)

AndalsoExp_NoMatch : TypedExp (TypedExp)
                   | TypedExp ANDALSO AndalsoExp_NoMatch (MkAndAlsoExp (span(TypedExpleft, AndalsoExp_NoMatchright), TypedExp, AndalsoExp_NoMatch)) (* [derived] conjunction *)
                   | TypedExp ANDALSO HeadExp_NoMatch (MkAndAlsoExp (span(TypedExpleft, HeadExp_NoMatchright), TypedExp, HeadExp_NoMatch)) (* [derived] conjunction *)

OrelseExp : AndalsoExp (AndalsoExp)
          | AndalsoExp_NoHead ORELSE OrelseExp (MkOrElseExp (span(AndalsoExp_NoHeadleft, OrelseExpright), AndalsoExp_NoHead, OrelseExp)) (* [derived] disjunction *)
          | AndalsoExp_NoHead ORELSE HeadExp (MkOrElseExp (span(AndalsoExp_NoHeadleft, HeadExpright), AndalsoExp_NoHead, HeadExp)) (* [derived] disjunction *)

OrelseExp_NoHead : AndalsoExp_NoHead (AndalsoExp_NoHead)
                 | AndalsoExp_NoHead ORELSE OrelseExp_NoHead (MkOrElseExp (span(AndalsoExp_NoHeadleft, OrelseExp_NoHeadright), AndalsoExp_NoHead, OrelseExp_NoHead)) (* [derived] disjunction *)

OrelseExp_NoMatch : AndalsoExp_NoMatch (AndalsoExp_NoMatch)
                  | AndalsoExp_NoHead ORELSE OrelseExp_NoMatch (MkOrElseExp (span(AndalsoExp_NoHeadleft, OrelseExp_NoMatchright), AndalsoExp_NoHead, OrelseExp_NoMatch)) (* [derived] disjunction *)
                  | AndalsoExp_NoHead ORELSE HeadExp_NoMatch (MkOrElseExp (span(AndalsoExp_NoHeadleft, HeadExp_NoMatchright), AndalsoExp_NoHead, HeadExp_NoMatch)) (* [derived] disjunction *)

(* expression with a starting token *)
HeadExp : RAISE Exp (UnfixedSyntax.RaiseExp(span(RAISEleft, Expright), Exp)) (* raise exception *)
        | IF Exp THEN Exp ELSE Exp (UnfixedSyntax.IfThenElseExp (span(IFleft, Exp3right), Exp1, Exp2, Exp3)) (* [derived] conditional *)
        | WHILE Exp DO Exp (UnfixedSyntax.WhileDoExp (span(WHILEleft, Exp2right), Exp1, Exp2)) (* [derived] iteration *)
        | CASE Exp OF MatchClauses (UnfixedSyntax.CaseExp (span(CASEleft, MatchClausesright), Exp, MatchClauses)) (* [derived] pattern match: (fn MatchClauses)(Exp) *)
        | FN MatchClauses (UnfixedSyntax.FnExp(span(FNleft, MatchClausesright), MatchClauses)) (* function *)

HeadExp_NoMatch : RAISE Exp_NoMatch (UnfixedSyntax.RaiseExp(span(RAISEleft, Exp_NoMatchright), Exp_NoMatch)) (* raise exception *)
                | IF Exp THEN Exp ELSE Exp_NoMatch (UnfixedSyntax.IfThenElseExp (span(IFleft, Exp_NoMatchright), Exp1, Exp2, Exp_NoMatch))
                | WHILE Exp DO Exp_NoMatch (UnfixedSyntax.WhileDoExp (span(WHILEleft, Exp_NoMatchright), Exp, Exp_NoMatch)) (* [derived] iteration *)

(* expression *)
Exp : OrelseExp (OrelseExp)
    | OrelseExp_NoHead HANDLE MatchClauses (UnfixedSyntax.HandleExp (span(OrelseExp_NoHeadleft, MatchClausesright), OrelseExp_NoHead, MatchClauses)) (* handle exception *)
    | HeadExp (HeadExp)

Exp_NoMatch : OrelseExp_NoMatch (OrelseExp_NoMatch)
            | HeadExp_NoMatch (HeadExp_NoMatch)

(* matches *)
MatchClauses : Pat DARROW Exp_NoMatch BAR MatchClauses ((Pat, Exp_NoMatch) :: MatchClauses)
             | Pat DARROW Exp ((Pat, Exp) :: nil)

(* a declaration, excluding local-in-end *)
Dec_NoLocal : VAL ValBind (UnfixedSyntax.ValDec (span(VALleft, ValBindright), nil, ValBind)) (* value declaration (non-recursive) *)
            | VAL TyVar ValBind (UnfixedSyntax.ValDec (span(VALleft, ValBindright), [TyVar], ValBind)) (* value declaration (non-recursive) *)
            | VAL LPAREN TyVar TyVarSeqRest RPAREN ValBind (UnfixedSyntax.ValDec (span(VALleft, ValBindright), TyVar :: TyVarSeqRest, ValBind)) (* value declaration (non-recursive) *)
            | VAL REC ValBind (UnfixedSyntax.RecValDec (span(VALleft, ValBindright), nil, ValBind)) (* value declaration (recursive) *)
            | VAL REC TyVar ValBind (UnfixedSyntax.RecValDec (span(VALleft, ValBindright), [TyVar], ValBind)) (* [Successor ML-style] value declaration (recursive) *)
            | VAL REC LPAREN TyVar TyVarSeqRest RPAREN ValBind (UnfixedSyntax.RecValDec (span(VALleft, ValBindright), TyVar :: TyVarSeqRest, ValBind)) (* [Successor ML-style] value declaration (recursive) *)
            | VAL TyVar REC ValBind (UnfixedSyntax.RecValDec (span(VALleft, ValBindright), [TyVar], ValBind)) (* [SML97-style] value declaration (recursive) *)
            | VAL LPAREN TyVar TyVarSeqRest RPAREN REC ValBind (UnfixedSyntax.RecValDec (span(VALleft, ValBindright), TyVar :: TyVarSeqRest, ValBind)) (* [SML97-style] value declaration (recursive) *)
            | FUN FValBind (UnfixedSyntax.FValDec (span(FUNleft, FValBindright), [], FValBind)) (* [derived] function declaration *)
            | FUN TyVar FValBind (UnfixedSyntax.FValDec (span(FUNleft, FValBindright), [TyVar], FValBind)) (* [derived] function declaration *)
            | FUN LPAREN TyVar TyVarSeqRest RPAREN FValBind (UnfixedSyntax.FValDec (span(FUNleft, FValBindright), TyVar :: TyVarSeqRest, FValBind)) (* [derived] function declaration *)
            | TYPE TypBind (UnfixedSyntax.TypeDec(span(TYPEleft, TypBindright), TypBind)) (* type declaration *)
            (* | DATATYPE DatBind (UnfixedSyntax.DatatypeDec(span(DATATYPEleft, DatBindright), DatBind)) (* datatype declaration *) *)
            | DATATYPE TyCon EQUALS ConBind DatBindRest Withtype (UnfixedSyntax.DatatypeDec(span(DATATYPEleft, Withtyperight), Syntax.DatBind (span(TyConleft, ConBindright), [], TyCon, ConBind) :: DatBindRest, Withtype)) (* datatype declaration *)
            | DATATYPE TyVar TyCon EQUALS ConBind DatBindRest Withtype (UnfixedSyntax.DatatypeDec(span(DATATYPEleft, Withtyperight), Syntax.DatBind (span(TyVarleft, ConBindright), [TyVar], TyCon, ConBind) :: DatBindRest, Withtype)) (* datatype declaration *)
            | DATATYPE LPAREN TyVar TyVarSeqRest RPAREN TyCon EQUALS ConBind DatBindRest Withtype (UnfixedSyntax.DatatypeDec(span(DATATYPEleft, Withtyperight), Syntax.DatBind (span(LPARENleft, ConBindright), TyVar :: TyVarSeqRest, TyCon, ConBind) :: DatBindRest, Withtype)) (* datatype declaration *)
            | DATATYPE TyCon EQUALS DATATYPE LongTyCon (UnfixedSyntax.DatatypeRepDec (span(DATATYPEleft, LongTyConright), TyCon, LongTyCon)) (* datatype replication *)
            | ABSTYPE DatBind Withtype WITH Decs END (UnfixedSyntax.AbstypeDec (span(ABSTYPEleft, ENDright), DatBind, Withtype, Decs)) (* abstype declaration *)
            | EXCEPTION ExBind (UnfixedSyntax.ExceptionDec(span(EXCEPTIONleft, ExBindright), ExBind)) (* exception declaration *)
            | OPEN LongStrIds (UnfixedSyntax.OpenDec(span(OPENleft, LongStrIdsright), LongStrIds)) (* open declaration *)
            | INFIX IntConst VIds (UnfixedSyntax.FixityDec (span(INFIXleft, VIdsright), Syntax.Infix (Syntax.LeftAssoc (Int.fromLarge IntConst)), VIds)) (* infix (L) directive *)
            | INFIX VIds (UnfixedSyntax.FixityDec (span(INFIXleft, VIdsright), Syntax.Infix (Syntax.LeftAssoc 0), VIds)) (* infix (L) directive *)
            | INFIXR IntConst VIds (UnfixedSyntax.FixityDec (span(INFIXRleft, VIdsright), Syntax.Infix (Syntax.RightAssoc (Int.fromLarge IntConst)), VIds)) (* infix (R) directive *)
            | INFIXR VIds (UnfixedSyntax.FixityDec (span(INFIXRleft, VIdsright), Syntax.Infix (Syntax.RightAssoc 0), VIds)) (* infix (R) directive *)
            | NONFIX VIds (UnfixedSyntax.FixityDec (span(NONFIXleft, VIdsright), Syntax.Nonfix, VIds)) (* nonfix directive *)
            | OVERLOAD AsciiStringConst LBRACK LongTyCon RBRACK LBRACE OverloadSpecs RBRACE (UnfixedSyntax.OverloadDec (span(OVERLOADleft, RBRACEright), #1 AsciiStringConst, LongTyCon, OverloadSpecs)) (* [extension] _overload "class" [ty] { + = ..., - = ..., ... } *)

OverloadSpec : AlnumIdent EQUALS Exp ((AlnumIdent, Exp))
             | SymbolicIdent EQUALS Exp ((SymbolicIdent, Exp))
             | ASTERISK EQUALS Exp (("*", Exp))

OverloadSpecs : OverloadSpec COMMA OverloadSpecs (OverloadSpec :: OverloadSpecs)
              | OverloadSpec ([OverloadSpec])

Dec : Dec_NoLocal (Dec_NoLocal)
    | LOCAL Decs IN Decs END (UnfixedSyntax.LocalDec (span(LOCALleft, ENDright), Decs1, Decs2)) (* local declaration *)

(* declarations *)
Decs : Dec Decs (Dec :: Decs)
     | SEMICOLON Decs (Decs) (* sequential declaration *)
     | (nil) (* empty declaration *)

(* LongStrId[1] ... LongStrId[n] *)
LongStrIds : LongStrId LongStrIds (LongStrId :: LongStrIds)
           | LongStrId (LongStrId :: nil)

(* VId[1] ... VId[n] *)
VIds : VId VIds (VId :: VIds)
     | VId (VId :: nil)

(* value bindings *)
ValBind : Pat EQUALS Exp AND ValBind (UnfixedSyntax.PatBind (span(Patleft, ValBindright), Pat, Exp) :: ValBind)
        | Pat EQUALS Exp (UnfixedSyntax.PatBind (span(Patleft, Expright), Pat, Exp) :: nil)
        (* | REC ValBind (UnfixedSyntax.RecValBind (span(RECleft, ValBindright), ValBind)) *)

FValBind : FMatch ([UnfixedSyntax.FValBind(span(FMatchleft, FMatchright), FMatch)])
         | FMatch AND FValBind (UnfixedSyntax.FValBind(span(FMatchleft, FMatchright), FMatch) :: FValBind)

FMatch : FMRule ([FMRule])
       | FMRule_NoMatch BAR FMatch (FMRule_NoMatch :: FMatch)

FMRule : FPat COLON Ty EQUALS Exp (UnfixedSyntax.FMRule (span(FPatleft, Expright), FPat, SOME Ty, Exp))
       | FPat EQUALS Exp (UnfixedSyntax.FMRule (span(FPatleft, Expright), FPat, NONE, Exp))

FMRule_NoMatch : FPat COLON Ty EQUALS Exp_NoMatch (UnfixedSyntax.FMRule (span(FPatleft, Exp_NoMatchright), FPat, SOME Ty, Exp_NoMatch))
               | FPat EQUALS Exp_NoMatch (UnfixedSyntax.FMRule (span(FPatleft, Exp_NoMatchright), FPat, NONE, Exp_NoMatch))

FPat : AtPats (UnfixedSyntax.FPat(span(AtPatsleft, AtPatsright), AtPats))
(*
       OP BoundVId AtPats
     | BoundVId AtPats
     | AtPat BoundVId AtPat
     | LPAREN AtPat BoundVId AtPat RPAREN
     | LPAREN AtPat BoundVId AtPat RPAREN AtPats
*)

(* type bindings *)
TypBind : TyVarSeq TyCon EQUALS Ty AND TypBind (Syntax.TypBind (span(TyVarSeqleft, Tyright), TyVarSeq, TyCon, Ty) :: TypBind)
        | TyVarSeq TyCon EQUALS Ty (Syntax.TypBind (span(TyVarSeqleft, Tyright), TyVarSeq, TyCon, Ty) :: nil)

(* datatype bindings *)
DatBind : TyVarSeq TyCon EQUALS ConBind DatBindRest (Syntax.DatBind (span(TyVarSeqleft, ConBindright), TyVarSeq, TyCon, ConBind) :: DatBindRest)

(* datatype bindings *)
DatBindRest : AND DatBind (DatBind)
            | (nil)

Withtype : WITHTYPE TypBind (TypBind)
         | (nil)

(* constructor bindings *)
ConBind : Opt_OP BoundVId OF Ty ConBindRest (Syntax.ConBind (span(Opt_OPleft, Tyright), BoundVId, SOME Ty) :: ConBindRest)
        | Opt_OP BoundVId ConBindRest (Syntax.ConBind (span(Opt_OPleft, BoundVIdright), BoundVId, NONE) :: ConBindRest)

ConBindRest : BAR ConBind (ConBind)
            | (nil)

(* exception bindings *)
ExBind : Opt_OP BoundVId OF Ty ExBindRest (Syntax.ExBind (span(Opt_OPleft, Tyright), BoundVId, SOME Ty) :: ExBindRest)
       | Opt_OP BoundVId ExBindRest (Syntax.ExBind (span(Opt_OPleft, BoundVIdright), BoundVId, NONE) :: ExBindRest)
       | Opt_OP BoundVId EQUALS Opt_OP LongVId ExBindRest (Syntax.ExReplication (span(Opt_OPleft, LongVIdright), BoundVId, LongVId) :: ExBindRest)

ExBindRest : AND ExBind (ExBind)
           | (nil)

AtStrExp : STRUCT StrDecs END (Syntax.StructExp(span(STRUCTleft, ENDright), StrDecs))
         | LongStrId (Syntax.StrIdExp(span(LongStrIdleft, LongStrIdright), LongStrId))
         | FunId LPAREN StrExp RPAREN (Syntax.FunctorAppExp(span(FunIdleft, RPARENright), FunId, StrExp))
         | FunId LPAREN StrDecs RPAREN (Syntax.FunctorAppExp(span(FunIdleft, RPARENright), FunId, Syntax.StructExp(span(StrDecsleft, StrDecsright), StrDecs))) (* derived form *)
         | LET StrDecs IN StrExp END (Syntax.LetInStrExp(span(LETleft, ENDright), StrDecs, StrExp))

StrExp : AtStrExp (AtStrExp)
       | StrExp COLON SigExp (Syntax.TransparentConstraintExp(span(StrExpleft, SigExpright), StrExp, SigExp)) (* transparent constraint *)
       | StrExp COLONGT SigExp (Syntax.OpaqueConstraintExp(span(StrExpleft, SigExpright), StrExp, SigExp)) (* opaque constraint *)

(* equivalent to 'StrExp AND' *)
StrExp_AND : AtStrExp AND (AtStrExp)
           | StrExp COLON SigExp_AND (Syntax.TransparentConstraintExp(span(StrExpleft, SigExp_ANDright), StrExp, SigExp_AND)) (* transparent constraint *)
           | StrExp COLONGT SigExp_AND (Syntax.OpaqueConstraintExp(span(StrExpleft, SigExp_ANDright), StrExp, SigExp_AND)) (* opaque constraint *)

ProperStrDec : STRUCTURE StrBind (Syntax.StrBindDec(span(STRUCTUREleft, StrBindright), StrBind))
             | LOCAL StrDecs IN StrDecs END (Syntax.LocalStrDec(span(LOCALleft, ENDright), StrDecs1, StrDecs2))

StrDecs : Dec_NoLocal StrDecs (Syntax.CoreDec(span(Dec_NoLocalleft, Dec_NoLocalright), Dec_NoLocal) :: StrDecs)
        | ProperStrDec StrDecs (ProperStrDec :: StrDecs)
        | SEMICOLON StrDecs (StrDecs)
        | ([])

StrBind : StrId SigConstraint EQUALS StrExp_AND StrBind ((StrId, SigConstraint StrExp_AND) :: StrBind)
        | StrId SigConstraint EQUALS StrExp ((StrId, SigConstraint StrExp) :: [])

Spec : VAL ValDesc ([Syntax.ValDesc(span(VALleft, ValDescright), ValDesc)])
     | TYPE TyVarSeq TyCon TypDescRest ([Syntax.TypeDesc(span(TYPEleft, TypDescRestright), (TyVarSeq, TyCon) :: TypDescRest)])
     | TYPE TyVarSeq TyCon EQUALS Ty TypDescEQRest ([Syntax.TypeAliasDesc(span(TYPEleft, TypDescEQRestright), (TyVarSeq, TyCon, Ty) :: TypDescEQRest)])
     | EQTYPE TypDesc ([Syntax.EqtypeDesc(span(EQTYPEleft, TypDescright), TypDesc)])
     (* | DATATYPE DatDesc (Syntax.DatDesc(span(DATATYPEleft, DatDescright), DatDesc)) *)
     | DATATYPE TyCon EQUALS ConDesc DatDescRest Withtype ([Syntax.DatDesc(span(DATATYPEleft, Withtyperight), ([], TyCon, ConDesc) :: DatDescRest, Withtype)])
     | DATATYPE TyVar TyCon EQUALS ConDesc DatDescRest Withtype ([Syntax.DatDesc(span(DATATYPEleft, Withtyperight), ([TyVar], TyCon, ConDesc) :: DatDescRest, Withtype)])
     | DATATYPE LPAREN TyVar TyVarSeqRest RPAREN TyCon EQUALS ConDesc DatDescRest Withtype ([Syntax.DatDesc(span(DATATYPEleft, Withtyperight), (TyVar :: TyVarSeqRest, TyCon, ConDesc) :: DatDescRest, Withtype)])
     | DATATYPE TyCon EQUALS DATATYPE LongTyCon ([Syntax.DatatypeRepSpec(span(DATATYPEleft, LongTyConright), TyCon, LongTyCon)])
     | EXCEPTION ExDesc ([Syntax.ExDesc(span(EXCEPTIONleft, ExDescright), ExDesc)])
     | STRUCTURE StrDesc ([Syntax.StrDesc(span(STRUCTUREleft, StrDescright), StrDesc)])
     | INCLUDE SigExp_NoSigId ([Syntax.Include(span(INCLUDEleft, SigExp_NoSigIdright), SigExp_NoSigId)])
     | INCLUDE SigIds (let val s = span(INCLUDEleft, SigIdsright) in List.map (fn sigid => Syntax.Include(s, Syntax.SigIdExp(s, sigid))) SigIds end)

ValDesc : VId COLON Ty ((VId, Ty) :: nil)
        | VId COLON Ty AND ValDesc ((VId, Ty) :: ValDesc)

TypDesc : TyVarSeq TyCon TypDescRest ((TyVarSeq, TyCon) :: TypDescRest)

TypDescRest : AND TyVarSeq TyCon TypDescRest ((TyVarSeq, TyCon) :: TypDescRest)
            | (nil)

TypDescEQRest : AND TyVarSeq TyCon EQUALS Ty TypDescEQRest ((TyVarSeq, TyCon, Ty) :: TypDescEQRest)
              | (nil)

DatDescRest : AND TyVarSeq TyCon EQUALS ConDesc DatDescRest ((TyVarSeq, TyCon, ConDesc) :: DatDescRest)
            | (nil)

ConDesc : VId ConDescRest (Syntax.ConBind(span(VIdleft, VIdright), VId, NONE) :: ConDescRest)
        | VId OF Ty ConDescRest (Syntax.ConBind(span(VIdleft, Tyright), VId, SOME Ty) :: ConDescRest)

ConDescRest : BAR ConDesc (ConDesc)
            | (nil)

ExDesc : VId ExDescRest ((VId, NONE) :: ExDescRest)
       | VId OF Ty ExDescRest ((VId, SOME Ty) :: ExDescRest)

ExDescRest : AND ExDesc (ExDesc)
           | (nil)

StrDesc : StrId COLON SigExp ((StrId, SigExp) :: nil)
        | StrId COLON SigExp_AND StrDesc ((StrId, SigExp_AND) :: StrDesc)

SigIds : SigId SigIds (SigId :: SigIds)
       | SigId (SigId :: nil)

Specs_NoSharing : ([])
                | Spec Specs_NoSharing (Spec @ Specs_NoSharing)
                | Spec SEMICOLON Specs_NoSharing (Spec @ Specs_NoSharing)

Specs : ([])
      | Spec Specs_NoSharing (Spec @ Specs_NoSharing)
      | Spec SEMICOLON Specs_NoSharing (Spec @ Specs_NoSharing)
      | Specs SHARING TYPE LongTyCon EQUAL_LongTyCons Specs_NoSharing (Syntax.Sharing(span(Specsleft, EQUAL_LongTyConsright), Specs, LongTyCon :: EQUAL_LongTyCons) :: Specs_NoSharing)
      | Specs SHARING LongStrId EQUAL_LongStrIds Specs_NoSharing (Syntax.SharingStructure(span(Specsleft, EQUAL_LongStrIdsright), Specs, LongStrId :: EQUAL_LongStrIds) :: Specs_NoSharing)

EQUAL_LongTyCons : EQUALS LongTyCon EQUAL_LongTyCons (LongTyCon :: EQUAL_LongTyCons)
                 | EQUALS LongTyCon (LongTyCon :: nil)

EQUAL_LongStrIds : EQUALS LongStrId EQUAL_LongStrIds (LongStrId :: EQUAL_LongStrIds)
                 | EQUALS LongStrId (LongStrId :: nil)

SigExp_NoSigId : SIG Specs END (Syntax.BasicSigExp(span(SIGleft, ENDright), Specs))
               | SigExp WHERE TYPE TyVarSeq LongTyCon EQUALS Ty TypeRealisationRest (List.foldl (fn ((span, tyvarseq, longtycon, ty), sigexp) => (* TODO: mark as "not available in Successor ML" *) Syntax.TypeRealisationExp (span, sigexp, tyvarseq, longtycon, ty)) (Syntax.TypeRealisationExp (span (SigExpleft, Tyright), SigExp, TyVarSeq, LongTyCon, Ty)) TypeRealisationRest)

SigExp : SigId (Syntax.SigIdExp(span(SigIdleft, SigIdright), SigId))
       | SigExp_NoSigId (SigExp_NoSigId)

(* equivalent to 'SigExp AND' *)
SigExp_AND : SIG Specs END AND (Syntax.BasicSigExp(span(SIGleft, ENDright), Specs))
           | SigId AND (Syntax.SigIdExp(span(SigIdleft, SigIdright), SigId))
           | SigExp WHERE TYPE TyVarSeq LongTyCon EQUALS Ty TypeRealisationRest_AND (List.foldl (fn ((span, tyvarseq, longtycon, ty), sigexp) => (* TODO: mark as "not available in Successor ML" *) Syntax.TypeRealisationExp (span, sigexp, tyvarseq, longtycon, ty)) (Syntax.TypeRealisationExp (span (SigExpleft, Tyright), SigExp, TyVarSeq, LongTyCon, Ty)) TypeRealisationRest_AND)

TypeRealisationRest : AND TYPE TyVarSeq LongTyCon EQUALS Ty TypeRealisationRest ((span (ANDleft, Tyright), TyVarSeq, LongTyCon, Ty) :: TypeRealisationRest) (* [removed in Successor ML] *)
                    | ([])

(* equivalent to 'TypeRealisationRest AND' *)
TypeRealisationRest_AND : AND TYPE TyVarSeq LongTyCon EQUALS Ty TypeRealisationRest_AND ((span (ANDleft, Tyright), TyVarSeq, LongTyCon, Ty) :: TypeRealisationRest_AND) (* [removed in Successor ML] *)
                        | AND ([])

SigBinds : SigId EQUALS SigExp ((SigId, SigExp) :: nil)
         | SigId EQUALS SigExp_AND SigBinds ((SigId, SigExp_AND) :: SigBinds)

SigDec : SIGNATURE SigBinds (SigBinds)

SigConstraint : (fn strexp => strexp)
              | COLON SigExp (fn strexp => Syntax.TransparentConstraintExp (span (COLONleft, SigExpright), strexp, SigExp))
              | COLONGT SigExp (fn strexp => Syntax.OpaqueConstraintExp (span (COLONGTleft, SigExpright), strexp, SigExp))

FunDec : FUNCTOR FunBind (FunBind)

FunBind : FunId LPAREN StrId COLON SigExp RPAREN SigConstraint EQUALS StrExp_AND FunBind ((span(FunIdleft, StrExp_ANDright), FunId, Syntax.NamedFunExp (StrId, SigExp, SigConstraint StrExp_AND)) :: FunBind)
        | FunId LPAREN Specs RPAREN SigConstraint EQUALS StrExp_AND FunBind ((span(FunIdleft, StrExp_ANDright), FunId, Syntax.AnonymousFunExp (Syntax.BasicSigExp(span(LPARENleft, RPARENright), Specs), SigConstraint StrExp_AND)) :: FunBind)
        | FunId LPAREN StrId COLON SigExp RPAREN SigConstraint EQUALS StrExp ((span(FunIdleft, StrExpright), FunId, Syntax.NamedFunExp (StrId, SigExp, SigConstraint StrExp)) :: [])
        | FunId LPAREN Specs RPAREN SigConstraint EQUALS StrExp ((span(FunIdleft, StrExpright), FunId, Syntax.AnonymousFunExp (Syntax.BasicSigExp(span(LPARENleft, RPARENright), Specs), SigConstraint StrExp)) :: [])

TopDecs : Dec_NoLocal TopDecs (Syntax.StrDec(Syntax.CoreDec(span(Dec_NoLocalleft, Dec_NoLocalright), Dec_NoLocal)) :: TopDecs) (* strdec *)
        | ProperStrDec TopDecs (Syntax.StrDec(ProperStrDec) :: TopDecs) (* strdec *)
        | SigDec TopDecs (Syntax.SigDec(SigDec) :: TopDecs)
        | FunDec TopDecs (Syntax.FunDec(FunDec) :: TopDecs)
        | (nil)

Program : TopDecs SEMICOLON Program (TopDecs :: Program)
        | Exp SEMICOLON Program ([Syntax.StrDec(Syntax.CoreDec(span(Expleft, Expright), UnfixedSyntax.ValDec(span(Expleft, Expright), nil, [UnfixedSyntax.PatBind(span(Expleft, Expright), UnfixedSyntax.NonInfixVIdPat(span(Expleft, Expleft), Syntax.MkLongVId([], Syntax.MkVId "it")), Exp)])))] :: Program) (* val it = Exp *)
        | TopDecs ([TopDecs]) (* topdecs without semicolon *)
