(*
 * Copyright (c) 2022 ARATA Mizuki
 * This file is part of LunarML.
 *)
fun nilPat span = UnfixedSyntax.NonInfixVIdPat (span, Syntax.MkLongVId (nil, Syntax.MkVId ("nil")))
fun trueExp span = UnfixedSyntax.NonInfixVIdExp (span, Syntax.MkLongVId (nil, Syntax.MkVId ("true")))
fun falseExp span = UnfixedSyntax.NonInfixVIdExp (span, Syntax.MkLongVId (nil, Syntax.MkVId ("false")))
fun MkAndAlsoExp (span,e1,e2) = UnfixedSyntax.IfThenElseExp (span, e1, e2, falseExp span)
fun MkOrElseExp (span,e1,e2) = UnfixedSyntax.IfThenElseExp (span, e1, trueExp span, e2)
fun MkListExp (span, xs) = UnfixedSyntax.ListExp(span, Vector.fromList xs)
fun MkVectorExp (span, xs) = UnfixedSyntax.VectorExp(span, Vector.fromList xs)
fun MkPairPat (span, p1, p2) = UnfixedSyntax.TuplePat(span, [p1, p2])
fun MkConsPat (span, p1, p2) = UnfixedSyntax.ConPat(span, Syntax.MkLongVId(nil, Syntax.MkVId("::")), MkPairPat(span, p1, p2))
fun MkListPat (span, nil) = nilPat span
  | MkListPat (span, x :: xs) = MkConsPat (span, x, MkListPat (span, xs))
fun MkVectorPat (span, xs, ellipsis) = UnfixedSyntax.VectorPat(span, Vector.fromList xs, ellipsis)
fun MkSequentialExp (span, x, xs, optSemi) = let fun go (final, [], acc) = UnfixedSyntax.SequentialExp (span, Vector.fromList (List.rev acc), final, optSemi)
                                                   | go (s, t :: ts, acc) = go (t, ts, s :: acc)
                                             in go (x, xs, [])
                                             end
fun MkTupleTy(_,[x]) = x
  | MkTupleTy (span, xs) = let fun doFields _ nil = nil
                                 | doFields i (t :: ts) = (Syntax.NumericLabel i, t) :: doFields (i + 1) ts
                           in Syntax.RecordType (span, doFields 1 xs, NONE)
                           end
fun span(p1,p2) = { start = p1, end_ = p2 }
%%

%eop EOF
%pos SourcePos.pos
%pure
%arg (filename) : string

%term AlnumIdent of string (* alphanumeric identifier not starting with a prime *)
    | QualifiedAlnumIdent of string list * string
    | DotAlnumIdent of string (* alphanumeric identifier with leading dot (may be used by future extension) *)
    | PrimeIdent of string (* alphanumeric identifier starting with a prime *)
    | SymbolicIdent of string
    | QualifiedSymbolicIdent of string list * string
    | DotSymbolicIdent of string (* identifier with leading dot (may be used by future extension) *)
    | InfixIdent of string (* identifier with prefix and postfix dots (extension) *)
    | QualifiedInfixIdent of string list * string (* identifier with prefix and postfix dots (extension) *)
    | PrimIdent of string (* identifiers prefixed by "_Prim." (extension) *)
    | PosInt of IntInf.int (* positive integer literal, not starting with 0, and not containing any underscore *)
    | ZNIntConst of IntInf.int (* starting with 0, or negative integer literal, or contains an underscore *)
    | WordConst of IntInf.int (* non-negative *)
    | RealConst of Numeric.float_notation
    | StringConst of StringElement.char vector
    | AsciiStringConst of string * StringElement.char vector
    | CharacterConst of StringElement.char
    (* * *)
    | ASTERISK
    (* . *)
    | DOT (* not used by the grammar *)
    (* ( ) [ ] { } , : *)
    | LPAREN | RPAREN | LBRACK | RBRACK | LBRACE | RBRACE | COMMA | COLON
    (* ; ... _ | = => -> # *)
    | SEMICOLON | ELLIPSIS | UNDERSCORE | BAR | EQUALS | DARROW | ARROW | HASH
    (* :> *)
    | COLONGT
    (* #[ (extension) *)
    | HASHLBRACK
    (* reserved words *)
    | ABSTYPE | AND | ANDALSO | AS | CASE | DATATYPE | DO | ELSE | END | EQTYPE
    | EXCEPTION | FN | FUN | FUNCTOR | HANDLE | IF | IN | INCLUDE | INFIX
    | INFIXR | LET | LOCAL | NONFIX | OF | OP | OPEN | ORELSE | RAISE | REC
    | SHARING | SIG | SIGNATURE | STRUCT | STRUCTURE | THEN | TYPE | VAL | WITH
    | WITHTYPE | WHERE | WHILE
    (* reserved words (extension) *)
    | PRIMNS | PRIMCALL | OVERLOAD | EQUALITY | ESIMPORT
    (* contextual keyword *)
    | FROM | PURE
    (* special comment (extension) *)
    | START_VAL_DESC_COMMENT | END_SPECIAL_COMMENT
    (* other *)
    | EOF
%nonterm START of ((UnfixedSyntax.Dec Syntax.TopDec) list) list
       | IntConst of IntInf.int
       | SCon of Syntax.SCon
       | TyVar of Syntax.TyVar
       | VId of Syntax.VId
       | BoundVId of Syntax.VId
       | StrId of Syntax.StrId
       | SigId of Syntax.SigId
       | FunId of Syntax.FunId
       | Lab of Syntax.Label
       | TyCon of Syntax.TyCon
       | TyCon_NoFROM of Syntax.TyCon
       | LongVId of Syntax.LongVId
       | LongBoundVId of Syntax.LongVId
       | LongTyCon of Syntax.LongTyCon
       | LongTyCon_NoFROM of Syntax.LongTyCon
       | LongStrId of Syntax.LongStrId
       | Opt_OP of bool
       | Opt_BAR of Syntax.optional_bar
       | AtPat of UnfixedSyntax.Pat
       | AtPats of UnfixedSyntax.Pat list
       | TypedPatPun of Syntax.Label * UnfixedSyntax.Pat * bool
       | PatPun of Syntax.Label * UnfixedSyntax.Pat * bool
       | PatRow of (UnfixedSyntax.Pat UnfixedSyntax.RecordItem) list
       | PatRowRest of (UnfixedSyntax.Pat UnfixedSyntax.RecordItem) list
       | TypedPat of UnfixedSyntax.Pat
       | Pat of UnfixedSyntax.Pat
       | PatSeqRest of UnfixedSyntax.Pat list
       | PatSeqRestEllipsis of UnfixedSyntax.Pat list * bool
       | AtTy of Syntax.Ty
       | ConTy of Syntax.Ty
       | TupTy of Syntax.Ty list
       | Ty of Syntax.Ty
       | ConTy_NoFROM of Syntax.Ty
       | TupTy_NoFROM of Syntax.Ty list
       | Ty_NoFROM of Syntax.Ty
       | TySeqRest of Syntax.Ty list
       | TyVarSeq of Syntax.TyVar list
       | TyVarSeqRest of Syntax.TyVar list
       | TyRow of (Syntax.Label * Syntax.Ty) list * Syntax.Ty option
       | COMMA_TyRow_NoELLIPSIS of (Syntax.Label * Syntax.Ty) list
       | AtExp of UnfixedSyntax.Exp
       | AppOrInfExp of UnfixedSyntax.Exp list
       | AppOrInfExp_NoHead of UnfixedSyntax.Exp list
       | AppOrInfExp_NoMatch of UnfixedSyntax.Exp list
       | ExpRow of (UnfixedSyntax.Exp UnfixedSyntax.RecordItem) list
       | ExpRowRest of (UnfixedSyntax.Exp UnfixedSyntax.RecordItem) list
       | ExpCSeqRest of UnfixedSyntax.Exp list
       | ExpSSeqRest of UnfixedSyntax.Exp list * UnfixedSyntax.optional_semicolon
       | TypedExp of UnfixedSyntax.Exp
       | TypedExp_NoHead of UnfixedSyntax.Exp
       | TypedExp_NoMatch of UnfixedSyntax.Exp
       | AndalsoExp of UnfixedSyntax.Exp
       | AndalsoExp_NoHead of UnfixedSyntax.Exp
       | AndalsoExp_NoMatch of UnfixedSyntax.Exp
       | OrelseExp of UnfixedSyntax.Exp
       | OrelseExp_NoHead of UnfixedSyntax.Exp
       | OrelseExp_NoMatch of UnfixedSyntax.Exp
       | Exp of UnfixedSyntax.Exp
       | Exp_NoMatch of UnfixedSyntax.Exp
       | HeadExp of UnfixedSyntax.Exp
       | HeadExp_NoMatch of UnfixedSyntax.Exp
       | MatchClauses of (UnfixedSyntax.Pat * UnfixedSyntax.Exp) list
       | ValDescInComment of (SourcePos.span * Syntax.VId * Syntax.Ty) list
       | ValDescInCommentVal of (SourcePos.span * Syntax.VId * Syntax.Ty) list
       | ValDescInCommentVals of (SourcePos.span * Syntax.VId * Syntax.Ty) list
       | ValDesc' of (SourcePos.span * Syntax.VId * Syntax.Ty) list
       | Dec_NoLocal of UnfixedSyntax.Dec
       | OverloadSpec of string * UnfixedSyntax.Exp
       | OverloadSpecs of (string * UnfixedSyntax.Exp) list
       | ESImportAttrs of { pure : bool }
       | ESImportSpec of Syntax.ESImportName * Syntax.VId * Syntax.Ty option
       | ESImportSpecs of (Syntax.ESImportName * Syntax.VId * Syntax.Ty option) list
       | ESImportSpecsRest of (Syntax.ESImportName * Syntax.VId * Syntax.Ty option) list
       | Dec of UnfixedSyntax.Dec
       | Decs of UnfixedSyntax.Dec list
       | LongStrIds of Syntax.LongStrId list
       | VIds of Syntax.ShortOrInfixVId list
       | ValBind of UnfixedSyntax.ValBind list
       | FValBind of UnfixedSyntax.FValBind list
       | FMatch of UnfixedSyntax.FMRule list
       | FMRule of UnfixedSyntax.FMRule
       | FMRule_NoMatch of UnfixedSyntax.FMRule
       | FPat of UnfixedSyntax.FPat
       | TypBind of Syntax.TypBind list
       | DatBind of Syntax.DatBind list
       | DatBindRest of Syntax.DatBind list
       | Withtype of Syntax.TypBind list
       | ConBind of Syntax.ConBind list
       | ConBindRest of Syntax.ConBind list
       | ExBind of Syntax.ExBind list
       | ExBindRest of Syntax.ExBind list
       | AtStrExp of UnfixedSyntax.Dec Syntax.StrExp
       | StrExp of UnfixedSyntax.Dec Syntax.StrExp
       | StrExp_AND of UnfixedSyntax.Dec Syntax.StrExp
       | ProperStrDec of UnfixedSyntax.Dec Syntax.StrDec
       | StrDecs of (UnfixedSyntax.Dec Syntax.StrDec) list
       | StrBind of (Syntax.StrId * UnfixedSyntax.Dec Syntax.StrExp) list
       | Spec of Syntax.Spec list
       | ValDesc of (Syntax.VId * Syntax.Ty) list
       | TypDesc of (Syntax.TyVar list * Syntax.TyCon) list
       | TypDescRest of (Syntax.TyVar list * Syntax.TyCon) list
       | TypDescEQRest of (Syntax.TyVar list * Syntax.TyCon * Syntax.Ty) list
       | DatDescRest of (Syntax.TyVar list * Syntax.TyCon * Syntax.optional_bar * Syntax.ConBind list) list
       | ConDesc of Syntax.ConBind list
       | ConDescRest of Syntax.ConBind list
       | ExDesc of (Syntax.VId * Syntax.Ty option) list
       | ExDescRest of (Syntax.VId * Syntax.Ty option) list
       | StrDesc of (Syntax.StrId * Syntax.SigExp) list
       | SigIds of Syntax.SigId list
       | Specs_NoSharing of Syntax.Spec list
       | Specs of Syntax.Spec list
       | EQUAL_LongTyCons of Syntax.LongTyCon list
       | EQUAL_LongStrIds of Syntax.LongStrId list
       | SigExp_NoSigId of Syntax.SigExp
       | SigExp of Syntax.SigExp
       | SigExp_AND of Syntax.SigExp
       | TypeRealisationRest of (SourcePos.span * Syntax.TyVar list * Syntax.LongTyCon * Syntax.Ty) list
       | TypeRealisationRest_AND of (SourcePos.span * Syntax.TyVar list * Syntax.LongTyCon * Syntax.Ty) list
       | SigBinds of (Syntax.SigId * Syntax.SigExp) list
       | SigDec of (Syntax.SigId * Syntax.SigExp) list
       | SigConstraint of UnfixedSyntax.Dec Syntax.StrExp -> UnfixedSyntax.Dec Syntax.StrExp
       | FunDec of (SourcePos.span * Syntax.FunId * UnfixedSyntax.Dec Syntax.FunExp) list
       | FunBind of (SourcePos.span * Syntax.FunId * UnfixedSyntax.Dec Syntax.FunExp) list
       | TopDecs of (UnfixedSyntax.Dec Syntax.TopDec) list
       | Program of ((UnfixedSyntax.Dec Syntax.TopDec) list) list

%name LunarML

%noshift EOF
%nodefault

%right ARROW (* function type expression *)

%verbose

%%

START : Program (Program)

IntConst : PosInt (PosInt)
         | ZNIntConst (ZNIntConst)

SCon : IntConst (Syntax.IntegerConstant IntConst)
     | WordConst (Syntax.WordConstant WordConst)
     | RealConst (Syntax.RealConstant RealConst)
     | StringConst (Syntax.StringConstant StringConst)
     | AsciiStringConst (Syntax.StringConstant (#2 AsciiStringConst))
     | CharacterConst (Syntax.CharacterConstant CharacterConst)

(* type variable *)
TyVar : PrimeIdent (Syntax.MkTyVar PrimeIdent)

(* value identifiers *)
VId : BoundVId (BoundVId)
    | EQUALS (Syntax.MkVId "=") (* ? *)

(* value identifiers, excluding '=' *)
BoundVId : AlnumIdent (Syntax.MkVId AlnumIdent)
         | FROM (Syntax.MkVId "from")
         | PURE (Syntax.MkVId "pure")
         | SymbolicIdent (Syntax.MkVId SymbolicIdent)
         | ASTERISK (Syntax.MkVId "*")

(* structure identifier *)
StrId : AlnumIdent (Syntax.MkStrId AlnumIdent)
      | FROM (Syntax.MkStrId "from")
      | PURE (Syntax.MkStrId "pure")

(* signature identifier *)
SigId : AlnumIdent (Syntax.MkSigId AlnumIdent)
      | FROM (Syntax.MkSigId "from")
      | PURE (Syntax.MkSigId "pure")

(* functor identifier *)
FunId : AlnumIdent (Syntax.MkFunId AlnumIdent)
      | FROM (Syntax.MkFunId "from")
      | PURE (Syntax.MkFunId "pure")

(* record labels *)
Lab : AlnumIdent (Syntax.IdentifierLabel AlnumIdent)
    | FROM (Syntax.IdentifierLabel "from")
    | PURE (Syntax.IdentifierLabel "pure")
    | SymbolicIdent (Syntax.IdentifierLabel SymbolicIdent)
    | ASTERISK (Syntax.IdentifierLabel "*")
    | PosInt (Syntax.NumericLabel (Int.fromLarge PosInt)) (* numeric labels *)

(* type constructors; "*" is not included *)
TyCon : AlnumIdent (Syntax.MkTyCon AlnumIdent)
      | FROM (Syntax.MkTyCon "from")
      | PURE (Syntax.MkTyCon "pure")
      | SymbolicIdent (Syntax.MkTyCon SymbolicIdent)

(* type constructors; neither "*" nor "from" is included *)
TyCon_NoFROM : AlnumIdent (Syntax.MkTyCon AlnumIdent)
             | PURE (Syntax.MkTyCon "pure")
             | SymbolicIdent (Syntax.MkTyCon SymbolicIdent)

(* long value identifiers, including '=' *)
LongVId : VId (Syntax.MkLongVId (nil, VId))
        | QualifiedAlnumIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedAlnumIdent), Syntax.MkVId (#2 QualifiedAlnumIdent)))
        | QualifiedSymbolicIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedSymbolicIdent), Syntax.MkVId (#2 QualifiedSymbolicIdent)))
        | PrimIdent (Syntax.MkQualified ([], Syntax.MkVId PrimIdent))

(* long value identifiers, excluding unqualified '=' *)
LongBoundVId : BoundVId (Syntax.MkLongVId (nil, BoundVId))
             | QualifiedAlnumIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedAlnumIdent), Syntax.MkVId (#2 QualifiedAlnumIdent)))
             | QualifiedSymbolicIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedSymbolicIdent), Syntax.MkVId (#2 QualifiedSymbolicIdent)))
             | PrimIdent (Syntax.MkQualified ([], Syntax.MkVId PrimIdent))

(* long type constructors *)
LongTyCon : TyCon (Syntax.MkLongTyCon (nil, TyCon))
          | QualifiedAlnumIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedAlnumIdent), Syntax.MkTyCon (#2 QualifiedAlnumIdent)))
          | QualifiedSymbolicIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedSymbolicIdent), Syntax.MkTyCon (#2 QualifiedSymbolicIdent)))
          | PrimIdent (Syntax.MkQualified ([], Syntax.MkTyCon PrimIdent))

(* long type constructors, excluding unqualified 'from' *)
LongTyCon_NoFROM : TyCon_NoFROM (Syntax.MkLongTyCon (nil, TyCon_NoFROM))
                 | QualifiedAlnumIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedAlnumIdent), Syntax.MkTyCon (#2 QualifiedAlnumIdent)))
                 | QualifiedSymbolicIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedSymbolicIdent), Syntax.MkTyCon (#2 QualifiedSymbolicIdent)))
                 | PrimIdent (Syntax.MkQualified ([], Syntax.MkTyCon PrimIdent))

(* long structure identifiers *)
LongStrId : StrId (Syntax.MkLongStrId (nil, StrId))
          | QualifiedAlnumIdent (Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedAlnumIdent), Syntax.MkStrId (#2 QualifiedAlnumIdent)))

Opt_OP : (* empty *) (false)
       | OP (true)

Opt_BAR : (* empty *) (Syntax.NO_BAR)
        | BAR (Syntax.HAS_BAR (span (BARleft, BARright)))

(* atomic patterns *)
AtPat : UNDERSCORE (UnfixedSyntax.WildcardPat(span(UNDERSCOREleft,UNDERSCOREright))) (* wildcard *)
      | SCon (UnfixedSyntax.SConPat(span(SConleft,SConright),SCon)) (* special constant *)
      | OP LongVId (UnfixedSyntax.NonInfixVIdPat(span(OPleft,LongVIdright),LongVId)) (* value identifier, including 'op =' *)
      | LongBoundVId (case LongBoundVId of
                          Syntax.MkQualified([], vid) => UnfixedSyntax.InfixOrVIdPat(span(LongBoundVIdleft,LongBoundVIdright),vid)
                        | longvid => UnfixedSyntax.NonInfixVIdPat(span(LongBoundVIdleft,LongBoundVIdright),longvid)
                     ) (* value identifier *)
      | LBRACE RBRACE (UnfixedSyntax.RecordPat (span (LBRACEleft, RBRACEright), [])) (* empty record *)
      | LBRACE PatRow RBRACE (UnfixedSyntax.RecordPat (span (LBRACEleft, RBRACEright), PatRow)) (* record *)
      | LPAREN RPAREN (UnfixedSyntax.RecordPat (span(LPARENleft,RPARENright), [])) (* [derived] empty tuple *)
      | LPAREN Pat RPAREN (case Pat of
                               UnfixedSyntax.InfixOrVIdPat _ => UnfixedSyntax.JuxtapositionPat(span(LPARENleft,RPARENright), [Pat])
                             | pat => pat
                          ) (* parenthesized pattern *)
      | LPAREN Pat COMMA Pat PatSeqRest RPAREN (UnfixedSyntax.TuplePat(span(LPARENleft,RPARENright), Pat1 :: Pat2 :: PatSeqRest)) (* [derived] tuple pattern *)
      | LBRACK RBRACK (nilPat (span(LBRACKleft,RBRACKright))) (* [derived] empty list *)
      | LBRACK Pat PatSeqRest RBRACK (MkListPat(span(LBRACKleft,RBRACKright), Pat :: PatSeqRest)) (* [derived] list pattern *)
      | HASHLBRACK RBRACK (MkVectorPat(span(HASHLBRACKleft,RBRACKright), [], false)) (* [extension] vector list *)
      | HASHLBRACK ELLIPSIS RBRACK (MkVectorPat(span(HASHLBRACKleft,RBRACKright), [], true)) (* [extension] vector list *)
      | HASHLBRACK Pat PatSeqRestEllipsis RBRACK (case PatSeqRestEllipsis of (PatSeqRest, ellipsis) => MkVectorPat(span(HASHLBRACKleft,RBRACKright), Pat :: PatSeqRest, ellipsis)) (* [extension] vector pattern *)

(* one or more atomic patterns *)
AtPats : AtPat ([AtPat])
       | AtPat AtPats (AtPat :: AtPats)
       | AtPat InfixIdent AtPats (AtPat :: UnfixedSyntax.InfixPat (span (InfixIdentleft, InfixIdentright), Syntax.MkQualified ([], Syntax.MkVId InfixIdent)) :: AtPats)
       | AtPat QualifiedInfixIdent AtPats (AtPat :: UnfixedSyntax.InfixPat (span (QualifiedInfixIdentleft, QualifiedInfixIdentright), Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedInfixIdent), Syntax.MkVId (#2 QualifiedInfixIdent))) :: AtPats)

TypedPat : AtPats (UnfixedSyntax.JuxtapositionPat(span(AtPatsleft, AtPatsright), AtPats))
         | TypedPat COLON Ty (UnfixedSyntax.TypedPat (span(TypedPatleft, Tyright), TypedPat, Ty)) (* typed *)

(* patterns *)
Pat : TypedPat (TypedPat)
(*
    | OP VId COLON Ty AS Pat (UnfixedSyntax.LayeredPat (OP_VId, SOME Ty, Pat)) (* layered *)
    | OP VId AS Pat (UnfixedSyntax.LayeredPat (OP_VId, NONE, Pat)) (* layered *)
    | BoundVId COLON Ty AS Pat (UnfixedSyntax.LayeredPat (OP_VId, SOME Ty, Pat)) (* layered *)
    | BoundVId AS Pat (UnfixedSyntax.LayeredPat (OP_VId, NONE, Pat)) (* layered *)
*)
    | TypedPat AS Pat (UnfixedSyntax.ConjunctivePat(span(TypedPatleft,Patright), TypedPat, Pat)) (* layered or [Successor ML] conjunctive (R) *)

TypedPatPun : BoundVId ((Syntax.IdentifierLabel (Syntax.getVIdName BoundVId), UnfixedSyntax.NonInfixVIdPat (span (BoundVIdleft, BoundVIdright), Syntax.MkQualified ([], BoundVId)), true))
            | BoundVId COLON Ty ((Syntax.IdentifierLabel (Syntax.getVIdName BoundVId), UnfixedSyntax.TypedPat (span (BoundVIdleft, Tyright), UnfixedSyntax.NonInfixVIdPat (span (BoundVIdleft, BoundVIdright), Syntax.MkQualified ([], BoundVId)), Ty), true))

PatPun : TypedPatPun (TypedPatPun)
       | TypedPatPun AS Pat ((#1 TypedPatPun, UnfixedSyntax.ConjunctivePat (span (TypedPatPunleft, Patright), #2 TypedPatPun, Pat), true))

(* pattern rows *)
PatRow : ELLIPSIS PatRowRest (UnfixedSyntax.Ellipsis (UnfixedSyntax.WildcardPat (span (ELLIPSISleft, ELLIPSISright))) :: PatRowRest) (* wildcard *)
       | ELLIPSIS EQUALS Pat PatRowRest (UnfixedSyntax.Ellipsis Pat :: PatRowRest) (* [Successor ML] ellipses *)
       | Lab EQUALS Pat PatRowRest (UnfixedSyntax.Field (Lab, Pat, false) :: PatRowRest) (* pattern row *)
       | PatPun PatRowRest (UnfixedSyntax.Field PatPun :: PatRowRest) (* [derived] punning *)

PatRowRest : COMMA PatRow (PatRow)
           | ([])

PatSeqRest : COMMA Pat PatSeqRest (Pat :: PatSeqRest)
           | (nil)

PatSeqRestEllipsis : COMMA Pat PatSeqRestEllipsis (case PatSeqRestEllipsis of (PatSeqRest, ellipsis) => (Pat :: PatSeqRest, ellipsis))
                   | COMMA ELLIPSIS ((nil, true))
                   | ((nil, false))

AtTy : TyVar (Syntax.TyVar(span(TyVarleft,TyVarright), TyVar))
     | LBRACE RBRACE (Syntax.RecordType(span(LBRACEleft, RBRACEright), nil, NONE)) (* record type expression *)
     | LBRACE TyRow RBRACE (Syntax.RecordType(span(LBRACEleft, RBRACEright), #1 TyRow, #2 TyRow)) (* record type expression *)
     | LPAREN Ty RPAREN (Ty)

ConTy : AtTy (AtTy)
      | ConTy LongTyCon (Syntax.TyCon (span (ConTyleft, LongTyConright), [ConTy], LongTyCon)) (* type construction *)
      | LongTyCon (Syntax.TyCon (span (LongTyConleft, LongTyConright), nil, LongTyCon)) (* type construction *)
      | LPAREN Ty COMMA Ty TySeqRest RPAREN LongTyCon (Syntax.TyCon (span (LPARENleft, LongTyConright), Ty1 :: Ty2 :: TySeqRest, LongTyCon)) (* type construction *)

(* tuple type *)
TupTy : ConTy ([ConTy])
      | ConTy ASTERISK TupTy (ConTy :: TupTy)

(* type expressions *)
Ty : TupTy (MkTupleTy(span(TupTyleft, TupTyright), TupTy))
   | TupTy ARROW Ty (Syntax.FnType (span(TupTyleft, Tyright), MkTupleTy(span(TupTyleft, TupTyright), TupTy), Ty)) (* function type expression (R) *)

ConTy_NoFROM : AtTy (AtTy)
             | ConTy_NoFROM LongTyCon_NoFROM (Syntax.TyCon (span (ConTy_NoFROMleft, LongTyCon_NoFROMright), [ConTy_NoFROM], LongTyCon_NoFROM)) (* type construction *)
             | LongTyCon_NoFROM (Syntax.TyCon (span (LongTyCon_NoFROMleft, LongTyCon_NoFROMright), nil, LongTyCon_NoFROM)) (* type construction *)
             | LPAREN Ty COMMA Ty TySeqRest RPAREN LongTyCon_NoFROM (Syntax.TyCon (span (LPARENleft, LongTyCon_NoFROMright), Ty1 :: Ty2 :: TySeqRest, LongTyCon_NoFROM)) (* type construction *)

(* tuple type, excluding unqualified 'from' *)
TupTy_NoFROM : ConTy_NoFROM ([ConTy_NoFROM])
             | ConTy_NoFROM ASTERISK TupTy_NoFROM (ConTy_NoFROM :: TupTy_NoFROM)

(* type expressions, excluding unqualified 'from' *)
Ty_NoFROM : TupTy_NoFROM (MkTupleTy (span (TupTy_NoFROMleft, TupTy_NoFROMright), TupTy_NoFROM))
          | TupTy_NoFROM ARROW Ty_NoFROM (Syntax.FnType (span (TupTy_NoFROMleft, Ty_NoFROMright), MkTupleTy (span (TupTy_NoFROMleft, TupTy_NoFROMright), TupTy_NoFROM), Ty_NoFROM)) (* function type expression (R) *)

TySeqRest : COMMA Ty TySeqRest (Ty :: TySeqRest) (* *)
          | (nil) (* empty *)

TyVarSeq : TyVar ([TyVar]) (* singleton sequence *)
         | (nil) (* empty sequence *)
         | LPAREN TyVar TyVarSeqRest RPAREN (TyVar :: TyVarSeqRest) (* sequence *)

TyVarSeqRest : COMMA TyVar TyVarSeqRest (TyVar :: TyVarSeqRest) (* *)
             | (nil) (* empty *)

(* type-expression rows *)
TyRow : Lab COLON Ty COMMA TyRow (((Lab, Ty) :: #1 TyRow, #2 TyRow)) (* type-expression row *)
      | Lab COLON Ty (([(Lab, Ty)], NONE)) (* type-expression row *)
      | ELLIPSIS COLON Ty COMMA_TyRow_NoELLIPSIS ((COMMA_TyRow_NoELLIPSIS, SOME Ty)) (* [Successor ML] ellipses *)

COMMA_TyRow_NoELLIPSIS : COMMA Lab COLON Ty COMMA_TyRow_NoELLIPSIS ((Lab, Ty) :: COMMA_TyRow_NoELLIPSIS) (* type-expression row *)
                       | ([]) (* type-expression row *)

(* atomic expressions *)
AtExp : SCon (UnfixedSyntax.SConExp(span(SConleft,SConright),SCon)) (* special constant *)
      | OP LongVId (UnfixedSyntax.NonInfixVIdExp(span(OPleft,LongVIdright),LongVId)) (* value identifier *)
      | LongBoundVId (case LongBoundVId of
                          Syntax.MkQualified([], vid) => UnfixedSyntax.InfixOrVIdExp(span(LongBoundVIdleft,LongBoundVIdright),vid)
                        | longvid => UnfixedSyntax.NonInfixVIdExp(span(LongBoundVIdleft,LongBoundVIdright),longvid)
                     ) (* value identifier *)
      | EQUALS (UnfixedSyntax.InfixOrVIdExp(span(EQUALSleft,EQUALSright),Syntax.MkVId "="))
      | LBRACE RBRACE (UnfixedSyntax.RecordExp (span (LBRACEleft, RBRACEright), [])) (* empty record *)
      | LBRACE ExpRow RBRACE (UnfixedSyntax.RecordExp (span (LBRACEleft, RBRACEright), ExpRow)) (* record *)
      | LBRACE AtExp WHERE RBRACE (UnfixedSyntax.RecordUpdateExp (span (LBRACEleft, RBRACEright), AtExp, [])) (* [Successor ML] record update *)
      | LBRACE AtExp WHERE ExpRow RBRACE (UnfixedSyntax.RecordUpdateExp (span (LBRACEleft, RBRACEright), AtExp, ExpRow)) (* [Successor ML] record update *)
      | LET Decs IN Exp END (UnfixedSyntax.LetInExp (span(LETleft,ENDright), Decs, Exp)) (* local declaration *)
      | LPAREN Exp RPAREN (case Exp of
                               UnfixedSyntax.InfixOrVIdExp _ => UnfixedSyntax.JuxtapositionExp(span(LPARENleft,RPARENright),[Exp])
                             | exp => exp
                          ) (* parenthesized expression *)
      | LPAREN Exp SEMICOLON RPAREN (MkSequentialExp (span (LPARENleft, RPARENright), case Exp of UnfixedSyntax.InfixOrVIdExp _ => UnfixedSyntax.JuxtapositionExp (span (LPARENleft, RPARENright),[Exp]) | exp => exp, [], UnfixedSyntax.HAS_SEMICOLON (span (SEMICOLONleft, SEMICOLONright)))) (* parenthesized expression *)
      | LPAREN RPAREN (UnfixedSyntax.RecordExp (span (LPARENleft, RPARENright), [])) (* [derived] 0-tuple *)
      | LPAREN Exp COMMA Exp ExpCSeqRest RPAREN (UnfixedSyntax.TupleExp (span(LPARENleft,RPARENright), Exp1 :: Exp2 :: ExpCSeqRest)) (* [derived] tuple: {1=Exp1,...,n=Expn} (n >= 2) *)
      | LPAREN Exp SEMICOLON Exp ExpSSeqRest RPAREN (MkSequentialExp (span (LPARENleft, RPARENright), Exp1, Exp2 :: #1 ExpSSeqRest, #2 ExpSSeqRest)) (* [derived] sequential execution *)
      | LET Decs IN Exp SEMICOLON Exp ExpSSeqRest END (UnfixedSyntax.LetInExp (span (LETleft, ENDright), Decs, MkSequentialExp (span (Exp1left, ExpSSeqRestright), Exp1, Exp2 :: #1 ExpSSeqRest, #2 ExpSSeqRest))) (* [derived] local declaration *)
      | LBRACK RBRACK (MkListExp(span(LBRACKleft,RBRACKright),[])) (* [derived] list: Exp1 :: ... :: Expn :: nil *)
      | LBRACK Exp ExpCSeqRest RBRACK (MkListExp(span(LBRACKleft,RBRACKright), Exp :: ExpCSeqRest)) (* [derived] list: Exp1 :: ... :: Expn :: nil *)
      | HASHLBRACK RBRACK (MkVectorExp(span(HASHLBRACKleft,RBRACKright), [])) (* [extension] vector expression *)
      | HASHLBRACK Exp ExpCSeqRest RBRACK (MkVectorExp(span(HASHLBRACKleft,RBRACKright), Exp :: ExpCSeqRest)) (* [extension] vector expression *)
      | HASH Lab (UnfixedSyntax.ProjectionExp(span(HASHleft,Labright), Lab)) (* [derived] projection: fn {Lab=VId,...} => VId *)
      | PRIMCALL AsciiStringConst LBRACK Ty TySeqRest RBRACK LPAREN RPAREN (UnfixedSyntax.PrimExp(span(PRIMCALLleft, RPARENright), #1 AsciiStringConst, vector (Ty :: TySeqRest), vector [])) (* [extension] _primCall "name" [tyargs] () *)
      | PRIMCALL AsciiStringConst LBRACK Ty TySeqRest RBRACK LPAREN Exp ExpCSeqRest RPAREN (UnfixedSyntax.PrimExp(span(PRIMCALLleft, RPARENright), #1 AsciiStringConst, vector (Ty :: TySeqRest), vector (Exp :: ExpCSeqRest))) (* [extension] _primCall "name" [tyargs] (args) *)
      | PRIMCALL AsciiStringConst LPAREN RPAREN (UnfixedSyntax.PrimExp(span(PRIMCALLleft, RPARENright), #1 AsciiStringConst, vector [], vector [])) (* [extension] _primCall "name" () *)
      | PRIMCALL AsciiStringConst LPAREN Exp ExpCSeqRest RPAREN (UnfixedSyntax.PrimExp(span(PRIMCALLleft, RPARENright), #1 AsciiStringConst, vector [], vector (Exp :: ExpCSeqRest))) (* [extension] _primCall "name" (args) *)

(* comma-separated list of expressions *)
ExpCSeqRest : COMMA Exp ExpCSeqRest (Exp :: ExpCSeqRest)
            | (nil)

(* semicolon-separated list of expressions *)
ExpSSeqRest : SEMICOLON Exp ExpSSeqRest ((Exp :: #1 ExpSSeqRest, #2 ExpSSeqRest))
            | SEMICOLON (([], UnfixedSyntax.HAS_SEMICOLON (span (SEMICOLONleft, SEMICOLONright))))
            | (([], UnfixedSyntax.NO_SEMICOLON))

(* expression rows *)
ExpRow : Lab EQUALS Exp ExpRowRest (UnfixedSyntax.Field (Lab, Exp, false) :: ExpRowRest)
       | ELLIPSIS EQUALS Exp ExpRowRest (UnfixedSyntax.Ellipsis Exp :: ExpRowRest) (* [Successor ML] ellipses *)
       | BoundVId ExpRowRest (UnfixedSyntax.Field (Syntax.IdentifierLabel (Syntax.getVIdName BoundVId), UnfixedSyntax.NonInfixVIdExp (span (BoundVIdleft, BoundVIdright), Syntax.MkQualified ([], BoundVId)), true) :: ExpRowRest) (* [Successor ML] record pun *)

ExpRowRest : COMMA ExpRow (ExpRow)
           | ([])

(*
AppExp : AtExp
       | AppExp AtExp
InfExp : AppExp
       | InfExp VId InfExp
       | InfExp VId HeadExp (* This is a syntax error, but parsed to produce better error messages *)
*)

AppOrInfExp : AtExp AppOrInfExp (AtExp :: AppOrInfExp) (* atomic *)
            | AtExp ([AtExp])
            | AtExp InfixIdent AppOrInfExp (AtExp :: UnfixedSyntax.InfixExp (span (InfixIdentleft, InfixIdentright), Syntax.MkQualified ([], Syntax.MkVId InfixIdent)) :: AppOrInfExp)
            | AtExp QualifiedInfixIdent AppOrInfExp (AtExp :: UnfixedSyntax.InfixExp (span (QualifiedInfixIdentleft, QualifiedInfixIdentright), Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedInfixIdent), Syntax.MkVId (#2 QualifiedInfixIdent))) :: AppOrInfExp)
            | AtExp HeadExp (AtExp :: [UnfixedSyntax.MissingParenExp HeadExp])
            | AtExp InfixIdent HeadExp (AtExp :: [UnfixedSyntax.InfixExp (span (InfixIdentleft, InfixIdentright), Syntax.MkQualified ([], Syntax.MkVId InfixIdent)), UnfixedSyntax.MissingParenExp HeadExp])
            | AtExp QualifiedInfixIdent HeadExp (AtExp :: [UnfixedSyntax.InfixExp (span (QualifiedInfixIdentleft, QualifiedInfixIdentright), Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedInfixIdent), Syntax.MkVId (#2 QualifiedInfixIdent))), UnfixedSyntax.MissingParenExp HeadExp])

AppOrInfExp_NoHead : AtExp AppOrInfExp_NoHead (AtExp :: AppOrInfExp_NoHead) (* atomic *)
                   | AtExp ([AtExp])
                   | AtExp InfixIdent AppOrInfExp_NoHead (AtExp :: UnfixedSyntax.InfixExp (span (InfixIdentleft, InfixIdentright), Syntax.MkQualified ([], Syntax.MkVId InfixIdent)) :: AppOrInfExp_NoHead)
                   | AtExp QualifiedInfixIdent AppOrInfExp_NoHead (AtExp :: UnfixedSyntax.InfixExp (span (QualifiedInfixIdentleft, QualifiedInfixIdentright), Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedInfixIdent), Syntax.MkVId (#2 QualifiedInfixIdent))) :: AppOrInfExp_NoHead)

AppOrInfExp_NoMatch : AtExp AppOrInfExp_NoMatch (AtExp :: AppOrInfExp_NoMatch) (* atomic *)
                    | AtExp ([AtExp])
                    | AtExp InfixIdent AppOrInfExp_NoMatch (AtExp :: UnfixedSyntax.InfixExp (span (InfixIdentleft, InfixIdentright), Syntax.MkQualified ([], Syntax.MkVId InfixIdent)) :: AppOrInfExp_NoMatch)
                    | AtExp QualifiedInfixIdent AppOrInfExp_NoMatch (AtExp :: UnfixedSyntax.InfixExp (span (QualifiedInfixIdentleft, QualifiedInfixIdentright), Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedInfixIdent), Syntax.MkVId (#2 QualifiedInfixIdent))) :: AppOrInfExp_NoMatch)
                    | AtExp HeadExp_NoMatch (AtExp :: [UnfixedSyntax.MissingParenExp HeadExp_NoMatch])
                    | AtExp InfixIdent HeadExp_NoMatch (AtExp :: [UnfixedSyntax.InfixExp (span (InfixIdentleft, InfixIdentright), Syntax.MkQualified ([], Syntax.MkVId InfixIdent)), UnfixedSyntax.MissingParenExp HeadExp_NoMatch])
                    | AtExp QualifiedInfixIdent HeadExp_NoMatch (AtExp :: [UnfixedSyntax.InfixExp (span (QualifiedInfixIdentleft, QualifiedInfixIdentright), Syntax.MkQualified (List.map Syntax.MkStrId (#1 QualifiedInfixIdent), Syntax.MkVId (#2 QualifiedInfixIdent))), UnfixedSyntax.MissingParenExp HeadExp_NoMatch])

TypedExp : AppOrInfExp (UnfixedSyntax.JuxtapositionExp(span(AppOrInfExpleft,AppOrInfExpright), AppOrInfExp))
         | TypedExp_NoHead COLON Ty (UnfixedSyntax.TypedExp (span(TypedExp_NoHeadleft,Tyright), TypedExp_NoHead, Ty)) (* typed (L) *)

TypedExp_NoHead : AppOrInfExp_NoHead (UnfixedSyntax.JuxtapositionExp(span(AppOrInfExp_NoHeadleft,AppOrInfExp_NoHeadright), AppOrInfExp_NoHead))
                | TypedExp_NoHead COLON Ty (UnfixedSyntax.TypedExp (span(TypedExp_NoHeadleft,Tyright), TypedExp_NoHead, Ty)) (* typed (L) *)

TypedExp_NoMatch : AppOrInfExp_NoMatch (UnfixedSyntax.JuxtapositionExp(span(AppOrInfExp_NoMatchleft,AppOrInfExp_NoMatchright), AppOrInfExp_NoMatch))
                 | TypedExp_NoHead COLON Ty (UnfixedSyntax.TypedExp (span(TypedExp_NoHeadleft,Tyright), TypedExp_NoHead, Ty)) (* typed (L) *)

AndalsoExp : TypedExp (TypedExp)
           | TypedExp_NoHead ANDALSO AndalsoExp (MkAndAlsoExp (span(TypedExp_NoHeadleft, AndalsoExpright), TypedExp_NoHead, AndalsoExp)) (* [derived] conjunction *)
           | TypedExp_NoHead ANDALSO HeadExp (MkAndAlsoExp (span(TypedExp_NoHeadleft, HeadExpright), TypedExp_NoHead, HeadExp)) (* [derived] conjunction *)

AndalsoExp_NoHead : TypedExp_NoHead (TypedExp_NoHead)
                  | TypedExp_NoHead ANDALSO AndalsoExp_NoHead (MkAndAlsoExp (span(TypedExp_NoHeadleft, AndalsoExp_NoHeadright), TypedExp_NoHead, AndalsoExp_NoHead)) (* [derived] conjunction *)

AndalsoExp_NoMatch : TypedExp_NoMatch (TypedExp_NoMatch)
                   | TypedExp_NoHead ANDALSO AndalsoExp_NoMatch (MkAndAlsoExp (span(TypedExp_NoHeadleft, AndalsoExp_NoMatchright), TypedExp_NoHead, AndalsoExp_NoMatch)) (* [derived] conjunction *)
                   | TypedExp_NoHead ANDALSO HeadExp_NoMatch (MkAndAlsoExp (span(TypedExp_NoHeadleft, HeadExp_NoMatchright), TypedExp_NoHead, HeadExp_NoMatch)) (* [derived] conjunction *)

OrelseExp : AndalsoExp (AndalsoExp)
          | AndalsoExp_NoHead ORELSE OrelseExp (MkOrElseExp (span(AndalsoExp_NoHeadleft, OrelseExpright), AndalsoExp_NoHead, OrelseExp)) (* [derived] disjunction *)
          | AndalsoExp_NoHead ORELSE HeadExp (MkOrElseExp (span(AndalsoExp_NoHeadleft, HeadExpright), AndalsoExp_NoHead, HeadExp)) (* [derived] disjunction *)

OrelseExp_NoHead : AndalsoExp_NoHead (AndalsoExp_NoHead)
                 | AndalsoExp_NoHead ORELSE OrelseExp_NoHead (MkOrElseExp (span(AndalsoExp_NoHeadleft, OrelseExp_NoHeadright), AndalsoExp_NoHead, OrelseExp_NoHead)) (* [derived] disjunction *)

OrelseExp_NoMatch : AndalsoExp_NoMatch (AndalsoExp_NoMatch)
                  | AndalsoExp_NoHead ORELSE OrelseExp_NoMatch (MkOrElseExp (span(AndalsoExp_NoHeadleft, OrelseExp_NoMatchright), AndalsoExp_NoHead, OrelseExp_NoMatch)) (* [derived] disjunction *)
                  | AndalsoExp_NoHead ORELSE HeadExp_NoMatch (MkOrElseExp (span(AndalsoExp_NoHeadleft, HeadExp_NoMatchright), AndalsoExp_NoHead, HeadExp_NoMatch)) (* [derived] disjunction *)

(* expression with a starting token *)
HeadExp : RAISE Exp (UnfixedSyntax.RaiseExp(span(RAISEleft, Expright), Exp)) (* raise exception *)
        | IF Exp THEN Exp ELSE Exp (UnfixedSyntax.IfThenElseExp (span(IFleft, Exp3right), Exp1, Exp2, Exp3)) (* [derived] conditional *)
        | WHILE Exp DO Exp (UnfixedSyntax.WhileDoExp (span(WHILEleft, Exp2right), Exp1, Exp2)) (* [derived] iteration *)
        | CASE Exp OF Opt_BAR MatchClauses (UnfixedSyntax.CaseExp (span (CASEleft, MatchClausesright), Exp, Opt_BAR, MatchClauses)) (* [derived] pattern match: (fn MatchClauses)(Exp) *)
        | FN Opt_BAR MatchClauses (UnfixedSyntax.FnExp (span (FNleft, MatchClausesright), Opt_BAR, MatchClauses)) (* function *)

HeadExp_NoMatch : RAISE Exp_NoMatch (UnfixedSyntax.RaiseExp(span(RAISEleft, Exp_NoMatchright), Exp_NoMatch)) (* raise exception *)
                | IF Exp THEN Exp ELSE Exp_NoMatch (UnfixedSyntax.IfThenElseExp (span(IFleft, Exp_NoMatchright), Exp1, Exp2, Exp_NoMatch))
                | WHILE Exp DO Exp_NoMatch (UnfixedSyntax.WhileDoExp (span(WHILEleft, Exp_NoMatchright), Exp, Exp_NoMatch)) (* [derived] iteration *)

(* expression *)
Exp : OrelseExp (OrelseExp)
    | OrelseExp_NoHead HANDLE Opt_BAR MatchClauses (UnfixedSyntax.HandleExp (span (OrelseExp_NoHeadleft, MatchClausesright), OrelseExp_NoHead, Opt_BAR, MatchClauses)) (* handle exception *)
    | HeadExp (HeadExp)

Exp_NoMatch : OrelseExp_NoMatch (OrelseExp_NoMatch)
            | HeadExp_NoMatch (HeadExp_NoMatch)

(* matches *)
MatchClauses : Pat DARROW Exp_NoMatch BAR MatchClauses ((Pat, Exp_NoMatch) :: MatchClauses)
             | Pat DARROW Exp ((Pat, Exp) :: nil)

ValDescInComment : START_VAL_DESC_COMMENT ValDescInCommentVal ValDescInCommentVals END_SPECIAL_COMMENT ValDescInComment (ValDescInCommentVal @ ValDescInCommentVals @ ValDescInComment)
                 | ([])

ValDescInCommentVal : VAL ValDesc' (ValDesc')

ValDescInCommentVals : ValDescInCommentVal ValDescInCommentVals (ValDescInCommentVal @ ValDescInCommentVals)
                     | ([])

ValDesc' : VId COLON Ty ((span (VIdleft, Tyright), VId, Ty) :: nil)
         | VId COLON Ty AND ValDesc' ((span (VIdleft, Tyright), VId, Ty) :: ValDesc')

(* a declaration, excluding local-in-end *)
Dec_NoLocal : ValDescInComment VAL ValBind (UnfixedSyntax.ValDec (span (VALleft, ValBindright), [], ValDescInComment, ValBind)) (* value declaration (non-recursive) *)
            | ValDescInComment VAL TyVar ValBind (UnfixedSyntax.ValDec (span (VALleft, ValBindright), [TyVar], ValDescInComment, ValBind)) (* value declaration (non-recursive) *)
            | ValDescInComment VAL LPAREN TyVar TyVarSeqRest RPAREN ValBind (UnfixedSyntax.ValDec (span (VALleft, ValBindright), TyVar :: TyVarSeqRest, ValDescInComment, ValBind)) (* value declaration (non-recursive) *)
            | ValDescInComment VAL REC ValBind (UnfixedSyntax.RecValDec (span (VALleft, ValBindright), nil, UnfixedSyntax.TYVAR_REC, ValDescInComment, ValBind)) (* value declaration (recursive) *)
            | ValDescInComment VAL REC TyVar ValBind (UnfixedSyntax.RecValDec (span (VALleft, ValBindright), [TyVar], UnfixedSyntax.REC_TYVAR, ValDescInComment, ValBind)) (* [Successor ML-style] value declaration (recursive) *)
            | ValDescInComment VAL REC LPAREN TyVar TyVarSeqRest RPAREN ValBind (UnfixedSyntax.RecValDec (span (VALleft, ValBindright), TyVar :: TyVarSeqRest, UnfixedSyntax.REC_TYVAR, ValDescInComment, ValBind)) (* [Successor ML-style] value declaration (recursive) *)
            | ValDescInComment VAL TyVar REC ValBind (UnfixedSyntax.RecValDec (span (VALleft, ValBindright), [TyVar], UnfixedSyntax.TYVAR_REC, ValDescInComment, ValBind)) (* [SML97-style] value declaration (recursive) *)
            | ValDescInComment VAL LPAREN TyVar TyVarSeqRest RPAREN REC ValBind (UnfixedSyntax.RecValDec (span (VALleft, ValBindright), TyVar :: TyVarSeqRest, UnfixedSyntax.TYVAR_REC, ValDescInComment, ValBind)) (* [SML97-style] value declaration (recursive) *)
            | ValDescInComment FUN FValBind (UnfixedSyntax.FValDec (span (FUNleft, FValBindright), [], ValDescInComment, Syntax.NO_BAR, FValBind)) (* [derived] function declaration *)
            | ValDescInComment FUN BAR FValBind (UnfixedSyntax.FValDec (span (FUNleft, FValBindright), [], ValDescInComment, Syntax.HAS_BAR (span (BARleft, BARright)), FValBind)) (* [derived] function declaration *)
            | ValDescInComment FUN TyVar Opt_BAR FValBind (UnfixedSyntax.FValDec (span (FUNleft, FValBindright), [TyVar], ValDescInComment, Opt_BAR, FValBind)) (* [derived] function declaration *)
            | ValDescInComment FUN LPAREN TyVar TyVarSeqRest RPAREN Opt_BAR FValBind (UnfixedSyntax.FValDec (span (FUNleft, FValBindright), TyVar :: TyVarSeqRest, ValDescInComment, Opt_BAR, FValBind)) (* [derived] function declaration *)
            | TYPE TypBind (UnfixedSyntax.TypeDec(span(TYPEleft, TypBindright), TypBind)) (* type declaration *)
            (* | DATATYPE DatBind (UnfixedSyntax.DatatypeDec(span(DATATYPEleft, DatBindright), DatBind)) (* datatype declaration *) *)
            | DATATYPE TyCon EQUALS Opt_BAR ConBind DatBindRest Withtype (UnfixedSyntax.DatatypeDec (span (DATATYPEleft, Withtyperight), Syntax.DatBind (span (TyConleft, ConBindright), [], TyCon, Opt_BAR, ConBind) :: DatBindRest, Withtype)) (* datatype declaration *)
            | DATATYPE TyVar TyCon EQUALS Opt_BAR ConBind DatBindRest Withtype (UnfixedSyntax.DatatypeDec (span (DATATYPEleft, Withtyperight), Syntax.DatBind (span (TyVarleft, ConBindright), [TyVar], TyCon, Opt_BAR, ConBind) :: DatBindRest, Withtype)) (* datatype declaration *)
            | DATATYPE LPAREN TyVar TyVarSeqRest RPAREN TyCon EQUALS Opt_BAR ConBind DatBindRest Withtype (UnfixedSyntax.DatatypeDec (span (DATATYPEleft, Withtyperight), Syntax.DatBind (span (LPARENleft, ConBindright), TyVar :: TyVarSeqRest, TyCon, Opt_BAR, ConBind) :: DatBindRest, Withtype)) (* datatype declaration *)
            | DATATYPE TyCon EQUALS DATATYPE LongTyCon (UnfixedSyntax.DatatypeRepDec (span(DATATYPEleft, LongTyConright), TyCon, LongTyCon)) (* datatype replication *)
            | ABSTYPE DatBind Withtype WITH Decs END (UnfixedSyntax.AbstypeDec (span(ABSTYPEleft, ENDright), DatBind, Withtype, Decs)) (* abstype declaration *)
            | EXCEPTION ExBind (UnfixedSyntax.ExceptionDec(span(EXCEPTIONleft, ExBindright), ExBind)) (* exception declaration *)
            | OPEN LongStrIds (UnfixedSyntax.OpenDec(span(OPENleft, LongStrIdsright), LongStrIds)) (* open declaration *)
            | INFIX IntConst VIds (UnfixedSyntax.FixityDec (span(INFIXleft, VIdsright), Syntax.Infix (Syntax.LeftAssoc (Int.fromLarge IntConst)), VIds)) (* infix (L) directive *)
            | INFIX VIds (UnfixedSyntax.FixityDec (span(INFIXleft, VIdsright), Syntax.Infix (Syntax.LeftAssoc 0), VIds)) (* infix (L) directive *)
            | INFIXR IntConst VIds (UnfixedSyntax.FixityDec (span(INFIXRleft, VIdsright), Syntax.Infix (Syntax.RightAssoc (Int.fromLarge IntConst)), VIds)) (* infix (R) directive *)
            | INFIXR VIds (UnfixedSyntax.FixityDec (span(INFIXRleft, VIdsright), Syntax.Infix (Syntax.RightAssoc 0), VIds)) (* infix (R) directive *)
            | NONFIX VIds (UnfixedSyntax.FixityDec (span(NONFIXleft, VIdsright), Syntax.Nonfix, VIds)) (* nonfix directive *)
            | DO Exp (UnfixedSyntax.DoDec (span (DOleft, Expright), Exp)) (* [Successor ML] do declaration *)
            | OVERLOAD AsciiStringConst LBRACK LongTyCon RBRACK LBRACE OverloadSpecs RBRACE (UnfixedSyntax.OverloadDec (span(OVERLOADleft, RBRACEright), #1 AsciiStringConst, LongTyCon, OverloadSpecs)) (* [extension] _overload "class" [ty] { + = ..., - = ..., ... } *)
            | EQUALITY LongTyCon EQUALS Exp (UnfixedSyntax.EqualityDec (span(EQUALITYleft, Expright), [], LongTyCon, Exp)) (* [extension] _equality longtycon = exp *)
            | EQUALITY TyVar LongTyCon EQUALS Exp (UnfixedSyntax.EqualityDec (span(EQUALITYleft, Expright), [TyVar], LongTyCon, Exp)) (* [extension] _equality 'tyvar longtycon = exp *)
            | EQUALITY LPAREN TyVar TyVarSeqRest RPAREN LongTyCon EQUALS Exp (UnfixedSyntax.EqualityDec (span(EQUALITYleft, Expright), TyVar :: TyVarSeqRest, LongTyCon, Exp)) (* [extension] _equality ('tyvars...) longtycon = exp *)
            | ESIMPORT ESImportAttrs AsciiStringConst (UnfixedSyntax.ESImportDec { sourceSpan = span (ESIMPORTleft, AsciiStringConstright), pure = #pure ESImportAttrs, specs = [], moduleName = #1 AsciiStringConst }) (* [extension] _esImport [attr...] "module-name" *)
            | ESIMPORT ESImportAttrs VId FROM AsciiStringConst (UnfixedSyntax.ESImportDec { sourceSpan = span (ESIMPORTleft, AsciiStringConstright), pure = #pure ESImportAttrs, specs = [("default", VId, NONE)], moduleName = #1 AsciiStringConst }) (* [extension] _esImport [attr...] <vid> from "module-name" *)
            | ESIMPORT ESImportAttrs VId COLON Ty_NoFROM FROM AsciiStringConst (UnfixedSyntax.ESImportDec { sourceSpan = span (ESIMPORTleft, AsciiStringConstright), pure = #pure ESImportAttrs, specs = [("default", VId, SOME Ty_NoFROM)], moduleName = #1 AsciiStringConst }) (* [extension] _esImport [attr...] <vid> from "module-name" *)
            | ESIMPORT ESImportAttrs LBRACE ESImportSpecs RBRACE FROM AsciiStringConst (UnfixedSyntax.ESImportDec { sourceSpan = span (ESIMPORTleft, AsciiStringConstright), pure = #pure ESImportAttrs, specs = ESImportSpecs, moduleName = #1 AsciiStringConst }) (* [extension] _esImport [attr...] {spec...} from "module-name" *)
            | ESIMPORT ESImportAttrs VId COMMA LBRACE ESImportSpecs RBRACE FROM AsciiStringConst (UnfixedSyntax.ESImportDec { sourceSpan = span (ESIMPORTleft, AsciiStringConstright), pure = #pure ESImportAttrs, specs = ("default", VId, NONE) :: ESImportSpecs, moduleName = #1 AsciiStringConst }) (* [extension] _esImport [attr...] <vid>, {spec...} from "module-name" *)
            | ESIMPORT ESImportAttrs VId COLON Ty_NoFROM COMMA LBRACE ESImportSpecs RBRACE FROM AsciiStringConst (UnfixedSyntax.ESImportDec { sourceSpan = span (ESIMPORTleft, AsciiStringConstright), pure = #pure ESImportAttrs, specs = ("default", VId, SOME Ty_NoFROM) :: ESImportSpecs, moduleName = #1 AsciiStringConst }) (* [extension] _esImport [attr...] <vid>, {spec...} from "module-name" *)

OverloadSpec : AlnumIdent EQUALS Exp ((AlnumIdent, Exp))
             | FROM EQUALS Exp (("from", Exp))
             | PURE EQUALS Exp (("pure", Exp))
             | SymbolicIdent EQUALS Exp ((SymbolicIdent, Exp))
             | ASTERISK EQUALS Exp (("*", Exp))

OverloadSpecs : OverloadSpec COMMA OverloadSpecs (OverloadSpec :: OverloadSpecs)
              | OverloadSpec ([OverloadSpec])

ESImportAttrs : LBRACK PURE RBRACK ({ pure = true })
              | ({ pure = false })

ESImportSpec : VId ((Syntax.getVIdName VId, VId, NONE))
             | VId AS VId ((Syntax.getVIdName VId1, VId2, NONE))
             | AsciiStringConst AS VId ((#1 AsciiStringConst, VId, NONE))
             | VId COLON Ty ((Syntax.getVIdName VId, VId, SOME Ty))
             | VId AS VId COLON Ty ((Syntax.getVIdName VId1, VId2, SOME Ty))
             | AsciiStringConst AS VId COLON Ty ((#1 AsciiStringConst, VId, SOME Ty))

ESImportSpecs : ([])
              | ESImportSpec ESImportSpecsRest (ESImportSpec :: ESImportSpecsRest)

ESImportSpecsRest : ([])
                  | COMMA ESImportSpecs (ESImportSpecs)

Dec : Dec_NoLocal (Dec_NoLocal)
    | LOCAL Decs IN Decs END (UnfixedSyntax.LocalDec (span(LOCALleft, ENDright), Decs1, Decs2)) (* local declaration *)

(* declarations *)
Decs : Dec Decs (Dec :: Decs)
     | SEMICOLON Decs (Decs) (* sequential declaration *)
     | (nil) (* empty declaration *)

(* LongStrId[1] ... LongStrId[n] *)
LongStrIds : LongStrId LongStrIds (LongStrId :: LongStrIds)
           | LongStrId (LongStrId :: nil)

(* VId[1] ... VId[n] *)
VIds : VId VIds (Syntax.ShortVId VId :: VIds)
     | InfixIdent VIds (Syntax.InfixVId InfixIdent :: VIds)
     | VId (Syntax.ShortVId VId :: nil)
     | InfixIdent (Syntax.InfixVId InfixIdent :: nil)

(* value bindings *)
ValBind : Pat EQUALS Exp AND ValBind (UnfixedSyntax.PatBind (span(Patleft, ValBindright), Pat, Exp) :: ValBind)
        | Pat EQUALS Exp (UnfixedSyntax.PatBind (span(Patleft, Expright), Pat, Exp) :: nil)
        (* | REC ValBind (UnfixedSyntax.RecValBind (span(RECleft, ValBindright), ValBind)) *)

FValBind : FMatch ([UnfixedSyntax.FValBind(span(FMatchleft, FMatchright), FMatch)])
         | FMatch AND FValBind (UnfixedSyntax.FValBind(span(FMatchleft, FMatchright), FMatch) :: FValBind)

FMatch : FMRule ([FMRule])
       | FMRule_NoMatch BAR FMatch (FMRule_NoMatch :: FMatch)

FMRule : FPat COLON Ty EQUALS Exp (UnfixedSyntax.FMRule (span(FPatleft, Expright), FPat, SOME Ty, Exp))
       | FPat EQUALS Exp (UnfixedSyntax.FMRule (span(FPatleft, Expright), FPat, NONE, Exp))

FMRule_NoMatch : FPat COLON Ty EQUALS Exp_NoMatch (UnfixedSyntax.FMRule (span(FPatleft, Exp_NoMatchright), FPat, SOME Ty, Exp_NoMatch))
               | FPat EQUALS Exp_NoMatch (UnfixedSyntax.FMRule (span(FPatleft, Exp_NoMatchright), FPat, NONE, Exp_NoMatch))

FPat : AtPats (UnfixedSyntax.FPat(span(AtPatsleft, AtPatsright), AtPats))
(*
       OP BoundVId AtPats
     | BoundVId AtPats
     | AtPat BoundVId AtPat
     | LPAREN AtPat BoundVId AtPat RPAREN
     | LPAREN AtPat BoundVId AtPat RPAREN AtPats
*)

(* type bindings *)
TypBind : TyVarSeq TyCon EQUALS Ty AND TypBind (Syntax.TypBind (span(TyVarSeqleft, Tyright), TyVarSeq, TyCon, Ty) :: TypBind)
        | TyVarSeq TyCon EQUALS Ty (Syntax.TypBind (span(TyVarSeqleft, Tyright), TyVarSeq, TyCon, Ty) :: nil)

(* datatype bindings *)
DatBind : TyVarSeq TyCon EQUALS Opt_BAR ConBind DatBindRest (Syntax.DatBind (span (TyVarSeqleft, ConBindright), TyVarSeq, TyCon, Opt_BAR, ConBind) :: DatBindRest)

(* datatype bindings *)
DatBindRest : AND DatBind (DatBind)
            | (nil)

Withtype : WITHTYPE TypBind (TypBind)
         | (nil)

(* constructor bindings *)
ConBind : Opt_OP BoundVId OF Ty ConBindRest (Syntax.ConBind (span(Opt_OPleft, Tyright), BoundVId, SOME Ty) :: ConBindRest)
        | Opt_OP BoundVId ConBindRest (Syntax.ConBind (span(Opt_OPleft, BoundVIdright), BoundVId, NONE) :: ConBindRest)

ConBindRest : BAR ConBind (ConBind)
            | (nil)

(* exception bindings *)
ExBind : Opt_OP BoundVId OF Ty ExBindRest (Syntax.ExBind (span(Opt_OPleft, Tyright), BoundVId, SOME Ty) :: ExBindRest)
       | Opt_OP BoundVId ExBindRest (Syntax.ExBind (span(Opt_OPleft, BoundVIdright), BoundVId, NONE) :: ExBindRest)
       | Opt_OP BoundVId EQUALS Opt_OP LongVId ExBindRest (Syntax.ExReplication (span(Opt_OPleft, LongVIdright), BoundVId, LongVId) :: ExBindRest)

ExBindRest : AND ExBind (ExBind)
           | (nil)

AtStrExp : STRUCT StrDecs END (Syntax.StructExp(span(STRUCTleft, ENDright), StrDecs))
         | LongStrId (Syntax.StrIdExp(span(LongStrIdleft, LongStrIdright), LongStrId))
         | FunId LPAREN StrExp RPAREN (Syntax.FunctorAppExp(span(FunIdleft, RPARENright), FunId, StrExp))
         | FunId LPAREN StrDecs RPAREN (Syntax.FunctorAppExp(span(FunIdleft, RPARENright), FunId, Syntax.StructExp(span(StrDecsleft, StrDecsright), StrDecs))) (* derived form *)
         | LET StrDecs IN StrExp END (Syntax.LetInStrExp(span(LETleft, ENDright), StrDecs, StrExp))

StrExp : AtStrExp (AtStrExp)
       | StrExp COLON SigExp (Syntax.TransparentConstraintExp(span(StrExpleft, SigExpright), StrExp, SigExp)) (* transparent constraint *)
       | StrExp COLONGT SigExp (Syntax.OpaqueConstraintExp(span(StrExpleft, SigExpright), StrExp, SigExp)) (* opaque constraint *)

(* equivalent to 'StrExp AND' *)
StrExp_AND : AtStrExp AND (AtStrExp)
           | StrExp COLON SigExp_AND (Syntax.TransparentConstraintExp(span(StrExpleft, SigExp_ANDright), StrExp, SigExp_AND)) (* transparent constraint *)
           | StrExp COLONGT SigExp_AND (Syntax.OpaqueConstraintExp(span(StrExpleft, SigExp_ANDright), StrExp, SigExp_AND)) (* opaque constraint *)

ProperStrDec : STRUCTURE StrBind (Syntax.StrBindDec(span(STRUCTUREleft, StrBindright), StrBind))
             | LOCAL StrDecs IN StrDecs END (Syntax.LocalStrDec(span(LOCALleft, ENDright), StrDecs1, StrDecs2))

StrDecs : Dec_NoLocal StrDecs (Syntax.CoreDec(span(Dec_NoLocalleft, Dec_NoLocalright), Dec_NoLocal) :: StrDecs)
        | ProperStrDec StrDecs (ProperStrDec :: StrDecs)
        | SEMICOLON StrDecs (StrDecs)
        | ([])

StrBind : StrId SigConstraint EQUALS StrExp_AND StrBind ((StrId, SigConstraint StrExp_AND) :: StrBind)
        | StrId SigConstraint EQUALS StrExp ((StrId, SigConstraint StrExp) :: [])

Spec : VAL ValDesc ([Syntax.ValDesc(span(VALleft, ValDescright), ValDesc)])
     | TYPE TyVarSeq TyCon TypDescRest ([Syntax.TypeDesc(span(TYPEleft, TypDescRestright), (TyVarSeq, TyCon) :: TypDescRest)])
     | TYPE TyVarSeq TyCon EQUALS Ty TypDescEQRest ([Syntax.TypeAliasDesc(span(TYPEleft, TypDescEQRestright), (TyVarSeq, TyCon, Ty) :: TypDescEQRest)])
     | EQTYPE TypDesc ([Syntax.EqtypeDesc(span(EQTYPEleft, TypDescright), TypDesc)])
     (* | DATATYPE DatDesc (Syntax.DatDesc(span(DATATYPEleft, DatDescright), DatDesc)) *)
     | DATATYPE TyCon EQUALS Opt_BAR ConDesc DatDescRest Withtype ([Syntax.DatDesc (span (DATATYPEleft, Withtyperight), ([], TyCon, Opt_BAR, ConDesc) :: DatDescRest, Withtype)])
     | DATATYPE TyVar TyCon EQUALS Opt_BAR ConDesc DatDescRest Withtype ([Syntax.DatDesc (span (DATATYPEleft, Withtyperight), ([TyVar], TyCon, Opt_BAR, ConDesc) :: DatDescRest, Withtype)])
     | DATATYPE LPAREN TyVar TyVarSeqRest RPAREN TyCon EQUALS Opt_BAR ConDesc DatDescRest Withtype ([Syntax.DatDesc (span (DATATYPEleft, Withtyperight), (TyVar :: TyVarSeqRest, TyCon, Opt_BAR, ConDesc) :: DatDescRest, Withtype)])
     | DATATYPE TyCon EQUALS DATATYPE LongTyCon ([Syntax.DatatypeRepSpec(span(DATATYPEleft, LongTyConright), TyCon, LongTyCon)])
     | EXCEPTION ExDesc ([Syntax.ExDesc(span(EXCEPTIONleft, ExDescright), ExDesc)])
     | STRUCTURE StrDesc ([Syntax.StrDesc(span(STRUCTUREleft, StrDescright), StrDesc)])
     | INCLUDE SigExp_NoSigId ([Syntax.Include(span(INCLUDEleft, SigExp_NoSigIdright), SigExp_NoSigId)])
     | INCLUDE SigIds (let val s = span(INCLUDEleft, SigIdsright) in List.map (fn sigid => Syntax.Include(s, Syntax.SigIdExp(s, sigid))) SigIds end)

ValDesc : VId COLON Ty ((VId, Ty) :: nil)
        | VId COLON Ty AND ValDesc ((VId, Ty) :: ValDesc)

TypDesc : TyVarSeq TyCon TypDescRest ((TyVarSeq, TyCon) :: TypDescRest)

TypDescRest : AND TyVarSeq TyCon TypDescRest ((TyVarSeq, TyCon) :: TypDescRest)
            | (nil)

TypDescEQRest : AND TyVarSeq TyCon EQUALS Ty TypDescEQRest ((TyVarSeq, TyCon, Ty) :: TypDescEQRest)
              | (nil)

DatDescRest : AND TyVarSeq TyCon EQUALS Opt_BAR ConDesc DatDescRest ((TyVarSeq, TyCon, Opt_BAR, ConDesc) :: DatDescRest)
            | (nil)

ConDesc : VId ConDescRest (Syntax.ConBind(span(VIdleft, VIdright), VId, NONE) :: ConDescRest)
        | VId OF Ty ConDescRest (Syntax.ConBind(span(VIdleft, Tyright), VId, SOME Ty) :: ConDescRest)

ConDescRest : BAR ConDesc (ConDesc)
            | (nil)

ExDesc : VId ExDescRest ((VId, NONE) :: ExDescRest)
       | VId OF Ty ExDescRest ((VId, SOME Ty) :: ExDescRest)

ExDescRest : AND ExDesc (ExDesc)
           | (nil)

StrDesc : StrId COLON SigExp ((StrId, SigExp) :: nil)
        | StrId COLON SigExp_AND StrDesc ((StrId, SigExp_AND) :: StrDesc)

SigIds : SigId SigIds (SigId :: SigIds)
       | SigId (SigId :: nil)

Specs_NoSharing : ([])
                | Spec Specs_NoSharing (Spec @ Specs_NoSharing)
                | Spec SEMICOLON Specs_NoSharing (Spec @ Specs_NoSharing)

Specs : ([])
      | Spec Specs_NoSharing (Spec @ Specs_NoSharing)
      | Spec SEMICOLON Specs_NoSharing (Spec @ Specs_NoSharing)
      | Specs SHARING TYPE LongTyCon EQUAL_LongTyCons Specs_NoSharing (Syntax.Sharing(span(Specsleft, EQUAL_LongTyConsright), Specs, LongTyCon :: EQUAL_LongTyCons) :: Specs_NoSharing)
      | Specs SHARING LongStrId EQUAL_LongStrIds Specs_NoSharing (Syntax.SharingStructure(span(Specsleft, EQUAL_LongStrIdsright), Specs, LongStrId :: EQUAL_LongStrIds) :: Specs_NoSharing)

EQUAL_LongTyCons : EQUALS LongTyCon EQUAL_LongTyCons (LongTyCon :: EQUAL_LongTyCons)
                 | EQUALS LongTyCon (LongTyCon :: nil)

EQUAL_LongStrIds : EQUALS LongStrId EQUAL_LongStrIds (LongStrId :: EQUAL_LongStrIds)
                 | EQUALS LongStrId (LongStrId :: nil)

SigExp_NoSigId : SIG Specs END (Syntax.BasicSigExp(span(SIGleft, ENDright), Specs))
               | SigExp WHERE TYPE TyVarSeq LongTyCon EQUALS Ty TypeRealisationRest (List.foldl (fn ((span, tyvarseq, longtycon, ty), sigexp) => Syntax.TypeRealisationExp (span, sigexp, tyvarseq, longtycon, ty, true)) (Syntax.TypeRealisationExp (span (SigExpleft, Tyright), SigExp, TyVarSeq, LongTyCon, Ty, false)) TypeRealisationRest)

SigExp : SigId (Syntax.SigIdExp(span(SigIdleft, SigIdright), SigId))
       | SigExp_NoSigId (SigExp_NoSigId)

(* equivalent to 'SigExp AND' *)
SigExp_AND : SIG Specs END AND (Syntax.BasicSigExp(span(SIGleft, ENDright), Specs))
           | SigId AND (Syntax.SigIdExp(span(SigIdleft, SigIdright), SigId))
           | SigExp WHERE TYPE TyVarSeq LongTyCon EQUALS Ty TypeRealisationRest_AND (List.foldl (fn ((span, tyvarseq, longtycon, ty), sigexp) => Syntax.TypeRealisationExp (span, sigexp, tyvarseq, longtycon, ty, true)) (Syntax.TypeRealisationExp (span (SigExpleft, Tyright), SigExp, TyVarSeq, LongTyCon, Ty, false)) TypeRealisationRest_AND)

TypeRealisationRest : AND TYPE TyVarSeq LongTyCon EQUALS Ty TypeRealisationRest ((span (ANDleft, Tyright), TyVarSeq, LongTyCon, Ty) :: TypeRealisationRest) (* [removed in Successor ML] *)
                    | ([])

(* equivalent to 'TypeRealisationRest AND' *)
TypeRealisationRest_AND : AND TYPE TyVarSeq LongTyCon EQUALS Ty TypeRealisationRest_AND ((span (ANDleft, Tyright), TyVarSeq, LongTyCon, Ty) :: TypeRealisationRest_AND) (* [removed in Successor ML] *)
                        | AND ([])

SigBinds : SigId EQUALS SigExp ((SigId, SigExp) :: nil)
         | SigId EQUALS SigExp_AND SigBinds ((SigId, SigExp_AND) :: SigBinds)

SigDec : SIGNATURE SigBinds (SigBinds)

SigConstraint : (fn strexp => strexp)
              | COLON SigExp (fn strexp => Syntax.TransparentConstraintExp (span (COLONleft, SigExpright), strexp, SigExp))
              | COLONGT SigExp (fn strexp => Syntax.OpaqueConstraintExp (span (COLONGTleft, SigExpright), strexp, SigExp))

FunDec : FUNCTOR FunBind (FunBind)

FunBind : FunId LPAREN StrId COLON SigExp RPAREN SigConstraint EQUALS StrExp_AND FunBind ((span(FunIdleft, StrExp_ANDright), FunId, Syntax.NamedFunExp (StrId, SigExp, SigConstraint StrExp_AND)) :: FunBind)
        | FunId LPAREN Specs RPAREN SigConstraint EQUALS StrExp_AND FunBind ((span(FunIdleft, StrExp_ANDright), FunId, Syntax.AnonymousFunExp (Syntax.BasicSigExp(span(LPARENleft, RPARENright), Specs), SigConstraint StrExp_AND)) :: FunBind)
        | FunId LPAREN StrId COLON SigExp RPAREN SigConstraint EQUALS StrExp ((span(FunIdleft, StrExpright), FunId, Syntax.NamedFunExp (StrId, SigExp, SigConstraint StrExp)) :: [])
        | FunId LPAREN Specs RPAREN SigConstraint EQUALS StrExp ((span(FunIdleft, StrExpright), FunId, Syntax.AnonymousFunExp (Syntax.BasicSigExp(span(LPARENleft, RPARENright), Specs), SigConstraint StrExp)) :: [])

TopDecs : Dec_NoLocal TopDecs (Syntax.StrDec(Syntax.CoreDec(span(Dec_NoLocalleft, Dec_NoLocalright), Dec_NoLocal)) :: TopDecs) (* strdec *)
        | ProperStrDec TopDecs (Syntax.StrDec(ProperStrDec) :: TopDecs) (* strdec *)
        | SigDec TopDecs (Syntax.SigDec(SigDec) :: TopDecs)
        | FunDec TopDecs (Syntax.FunDec(FunDec) :: TopDecs)
        | (nil)

Program : TopDecs SEMICOLON Program (TopDecs :: Program)
        | Exp SEMICOLON Program ([Syntax.StrDec (Syntax.CoreDec (span (Expleft, Expright), UnfixedSyntax.ValDec (span (Expleft, Expright), [], [], [UnfixedSyntax.PatBind (span (Expleft, Expright), UnfixedSyntax.NonInfixVIdPat (span (Expleft, Expleft), Syntax.MkLongVId ([], Syntax.MkVId "it")), Exp)])))] :: Program) (* val it = Exp *)
        | TopDecs ([TopDecs]) (* topdecs without semicolon *)
